{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pybibtexer","text":""},{"location":"api-auto/","title":"API Reference","text":"<p>This is the complete API reference documentation for the pybibtexer library.</p>"},{"location":"api-auto/#module-list","title":"Module List","text":""},{"location":"api-auto/#root-modules","title":"Root Modules","text":"<ul> <li>bib.bibtexbase.standardize._base</li> <li>bib.bibtexbase.standardize.default_data</li> <li>bib.bibtexbase.standardize.do_on_bib</li> <li>bib.bibtexbase.standardize.do_on_comment_block</li> <li>bib.bibtexbase.standardize.do_on_entry_block</li> <li>bib.bibtexbase.standardize.do_on_preamble_block</li> <li>bib.bibtexbase.standardize.do_on_string_block</li> <li>bib.bibtexbase.standardize_bib</li> <li>bib.bibtexparser.bibtex_format</li> <li>bib.bibtexparser.exceptions</li> <li>bib.bibtexparser.library</li> <li>bib.bibtexparser.middlewares.block.add_field</li> <li>bib.bibtexparser.middlewares.block.authors</li> <li>bib.bibtexparser.middlewares.block.doi_url</li> <li>bib.bibtexparser.middlewares.block.entry_field_keys_normalize</li> <li>bib.bibtexparser.middlewares.block.entry_field_keys_replace</li> <li>bib.bibtexparser.middlewares.block.entry_field_values_normalize</li> <li>bib.bibtexparser.middlewares.block.entry_fields_delete</li> <li>bib.bibtexparser.middlewares.block.entry_fields_keep</li> <li>bib.bibtexparser.middlewares.block.entry_fields_sort</li> <li>bib.bibtexparser.middlewares.block.entry_types</li> <li>bib.bibtexparser.middlewares.block.journal_booktitle</li> <li>bib.bibtexparser.middlewares.block.month_year</li> <li>bib.bibtexparser.middlewares.block.number_volume</li> <li>bib.bibtexparser.middlewares.block.pages</li> <li>bib.bibtexparser.middlewares.block.title</li> <li>bib.bibtexparser.middlewares.library.generating_entrykeys</li> <li>bib.bibtexparser.middlewares.library.keeping_blocks</li> <li>bib.bibtexparser.middlewares.library.protecting_title</li> <li>bib.bibtexparser.middlewares.library.sorting_blocks</li> <li>bib.bibtexparser.middlewares.middleware</li> <li>bib.bibtexparser.middlewares.parsestack</li> <li>bib.bibtexparser.middlewares.utils</li> <li>bib.bibtexparser.middlewares_library_to_library</li> <li>bib.bibtexparser.middlewares_library_to_str</li> <li>bib.bibtexparser.middlewares_str_to_library</li> <li>bib.bibtexparser.middlewares_str_to_str</li> <li>bib.bibtexparser.model</li> <li>bib.bibtexparser.splitter</li> <li>bib.core.convert_library_to_library</li> <li>bib.core.convert_library_to_str</li> <li>bib.core.convert_str_to_library</li> <li>bib.core.convert_str_to_str</li> <li>main.basic_input</li> <li>main.python_run_bib</li> <li>main.python_writers</li> <li>main.utils</li> <li>scripts.run_generate_jsons</li> <li>tools.compare.compare_bibs</li> <li>tools.experiments_base</li> <li>tools.format_save_bibs</li> <li>tools.replace.replace</li> <li>tools.spider.process_spider_bib</li> <li>tools.spider.process_spider_url</li> <li>tools.spider.process_spider_url_bib</li> <li>utils.utils</li> </ul>"},{"location":"api-auto/bib.bibtexbase.standardize._base/","title":"bib.bibtexbase.standardize._base","text":"<p>Base utilities for BibTeX standardization.</p> <p>This module provides fundamental utility functions used throughout the standardization process, particularly for text processing and pattern matching.</p> <p>Functions:</p> Name Description <code>split_data_list</code> <p>Splits a list of strings according to a regex pattern, with options for handling the last element differently.</p>"},{"location":"api-auto/bib.bibtexbase.standardize._base/#pybibtexer.bib.bibtexbase.standardize._base-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexbase.standardize._base/#pybibtexer.bib.bibtexbase.standardize._base.split_data_list","title":"split_data_list","text":"<pre><code>split_data_list(split_pattern, data_list, last_next='next')\n</code></pre> <p>Split data list according to the split pattern.</p> <p>The capturing parentheses must be used in the pattern, such as <code>(\\n)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>split_pattern</code> <code>str</code> <p>split pattern.</p> required <code>data_list</code> <code>list[str]</code> <p>data list.</p> required <code>last_next</code> <code>str</code> <p>\"next\" or \"last\".</p> <code>'next'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: new data list.</p> <p>Examples:</p> <p>split_pattern = r\"(\\n)\", last_next = \"next\" or \"last\".</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/_base.py</code> <pre><code>def split_data_list(split_pattern: str, data_list: list[str], last_next: str = \"next\") -&gt; list[str]:\n    r\"\"\"Split data list according to the split pattern.\n\n    The capturing parentheses must be used in the pattern, such as `(\\n)`.\n\n    Args:\n        split_pattern (str): split pattern.\n        data_list (list[str]): data list.\n        last_next (str): \"next\" or \"last\".\n\n    Returns:\n        list[str]: new data list.\n\n    Examples:\n        split_pattern = r\"(\\n)\", last_next = \"next\" or \"last\".\n    \"\"\"\n    new_data_list = []\n    for line in data_list:\n        split_list = re.split(split_pattern, line)\n        list_one = split_list[0 : len(split_list) : 2]\n        list_two = split_list[1 : len(split_list) : 2]\n\n        temp = []\n        if last_next == \"next\":\n            list_two.insert(0, \"\")\n            temp = [list_two[i] + list_one[i] for i in range(len(list_one))]\n        if last_next == \"last\":\n            list_two.append(\"\")\n            temp = [list_one[i] + list_two[i] for i in range(len(list_one))]\n        new_data_list.extend(temp)\n    new_data_list = [line for line in new_data_list if line.strip()]\n    return new_data_list\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.default_data/","title":"bib.bibtexbase.standardize.default_data","text":"<p>Default data definitions for BibTeX standardization.</p> <p>This module contains default field lists and format flags used throughout the BibTeX standardization process. These definitions help ensure consistent field recognition and validation across different BibTeX entry types.</p> Constants <p>FIELD_FORMAT_FLAG: Regular expression patterns for identifying field     value delimiters (quotes, braces, and word characters). DEFAULT_FIELDS_LIST: Comprehensive list of standard BibTeX field names     that are recognized and processed during standardization.</p>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_bib/","title":"bib.bibtexbase.standardize.do_on_bib","text":"<p>BibTeX block splitting and parsing utilities.</p> <p>This module provides classes for splitting BibTeX data into blocks based on entry markers and organizing them into structured dictionaries for further processing.</p> <p>Classes:</p> Name Description <code>SplitBibAccordingToMark</code> <p>Splits BibTeX data into blocks based on entry type markers (e.g., @article, @book).</p> <code>ObtainMarkBlocksDict</code> <p>Parses split blocks and organizes them into a dictionary structure with implicit comment handling.</p>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_bib/#pybibtexer.bib.bibtexbase.standardize.do_on_bib-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_bib/#pybibtexer.bib.bibtexbase.standardize.do_on_bib.ObtainMarkBlocksDict","title":"ObtainMarkBlocksDict","text":"<pre><code>ObtainMarkBlocksDict()\n</code></pre> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_bib.py</code> <pre><code>def __init__(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_bib/#pybibtexer.bib.bibtexbase.standardize.do_on_bib.ObtainMarkBlocksDict-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_bib/#pybibtexer.bib.bibtexbase.standardize.do_on_bib.ObtainMarkBlocksDict.obtain_dict","title":"obtain_dict","text":"<pre><code>obtain_dict(data_list, is_lower_mark=True)\n</code></pre> <p>Generate blocks.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list[str]</code> <p>data list.</p> required <p>Returns:</p> Type Description <code>tuple[dict[str, list[list[str]]], list[list[str]]]</code> <p>tuple[dict[str, list[list[str]]], list[str]]: dict and implicit comments.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_bib.py</code> <pre><code>def obtain_dict(\n    self, data_list: list[str], is_lower_mark: bool = True\n) -&gt; tuple[dict[str, list[list[str]]], list[list[str]]]:\n    r\"\"\"Generate blocks.\n\n    Args:\n        data_list (list[str]): data list.\n\n    Returns:\n        tuple[dict[str, list[list[str]]], list[str]]: dict and implicit comments.\n    \"\"\"\n    regex_mark = re.compile(r\"@([a-zA-Z]+){\")\n    line_index, len_data, implicit_comment_list = 0, len(data_list), []\n    mark_patch_bib_list_dict: dict[str, list[list[str]]] = {}\n    while line_index &lt; len_data:\n        line = data_list[line_index]\n        line_index += 1\n        if mch := regex_mark.match(line):\n            mark = mch.group(1)\n            temp = [line]\n            while line_index &lt; len_data:\n                line = data_list[line_index]\n                if regex_mark.match(line):\n                    break\n                temp.append(line)\n                line_index += 1\n            if is_lower_mark:\n                mark = mark.lower()\n            mark_patch_bib_list_dict.setdefault(mark, []).append(temp)\n        else:\n            implicit_comment_list.append([line, __class__.__name__])\n    return mark_patch_bib_list_dict, implicit_comment_list\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_bib/#pybibtexer.bib.bibtexbase.standardize.do_on_bib-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_comment_block/","title":"bib.bibtexbase.standardize.do_on_comment_block","text":"<p>Comment block standardization utilities.</p> <p>This module provides functionality for processing and standardizing BibTeX comment blocks. Comment blocks in BibTeX are used for documentation and notes that should be preserved but formatted consistently.</p> <p>Classes:</p> Name Description <code>StandardizeCommentBlock</code> <p>Handles the standardization of @comment blocks, ensuring proper brace matching and formatting.</p>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_comment_block/#pybibtexer.bib.bibtexbase.standardize.do_on_comment_block-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_comment_block/#pybibtexer.bib.bibtexbase.standardize.do_on_comment_block.StandardizeCommentBlock","title":"StandardizeCommentBlock","text":"<pre><code>StandardizeCommentBlock()\n</code></pre> <p>Stanndardize comment block.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_comment_block.py</code> <pre><code>def __init__(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/","title":"bib.bibtexbase.standardize.do_on_entry_block","text":"<p>Entry block standardization utilities.</p> <p>This module provides comprehensive functionality for processing and standardizing BibTeX entry blocks. Entry blocks contain the actual bibliographic data and require the most complex processing including field validation, formatting, and error checking.</p> <p>Classes:</p> Name Description <code>StandardizeEntryBlock</code> <p>Main class for standardizing BibTeX entry blocks with configurable field lists and comprehensive validation.</p> <code>EntryBase</code> <p>Base class providing utility methods for field extraction and brace/quote detection.</p> <code>SplitEntry</code> <p>Handles splitting of entry blocks based on field patterns.</p> <code>AppendEntry</code> <p>Manages field appending and line continuation processing.</p> <code>ExtractEntry</code> <p>Extracts and validates field content from entry blocks.</p> <code>CheckEntry</code> <p>Performs final validation and error checking on entry blocks.</p> <p>Functions:</p> Name Description <code>add_brace_or_quote</code> <p>Utility function for ensuring proper brace/quote matching in field values.</p>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.AppendEntry","title":"AppendEntry","text":"<pre><code>AppendEntry()\n</code></pre> <p>Append Patch Bib.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_entry_block.py</code> <pre><code>def __init__(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.AppendEntry-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.AppendEntry.append_field","title":"append_field  <code>staticmethod</code>","text":"<pre><code>append_field(field_list, braces_or_quotes, block)\n</code></pre> <p>Append.</p> <p>Parameters:</p> Name Type Description Default <code>field_list</code> <code>list[str]</code> <p>Append field list.</p> required <code>braces_or_quotes</code> <code>tuple[str, str]</code> <p>Brace or quote.</p> required <code>block</code> <code>list[str]</code> <p>Data list.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: new patch bib after appending.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_entry_block.py</code> <pre><code>@staticmethod\ndef append_field(field_list: list[str], braces_or_quotes: tuple[str, str], block: list[str]) -&gt; list[str]:\n    \"\"\"Append.\n\n    Args:\n        field_list (list[str]): Append field list.\n        braces_or_quotes (tuple[str, str]): Brace or quote.\n        block (list[str]): Data list.\n\n    Returns:\n        list[str]: new patch bib after appending.\n    \"\"\"\n    pre, _ = braces_or_quotes\n\n    temp = rf\"[%\\s]*(?:{'|'.join(field_list)})\"\n    regex_field = re.compile(rf\"{temp}\\s*=\\s*{pre}\", flags=re.I)\n    regex_field_abbr = re.compile(rf\"{temp}\\s*=\\s*\\w+[\\w\\-]*\", flags=re.I)  # journal = EJC,\n    regex_termination = re.compile(r\"\\s*@[a-zA-Z]*{\", flags=re.I)\n\n    # strip and append\n    line_index, len_data, new_block = 0, len(block), []\n    while line_index &lt; len_data:\n        line = block[line_index]\n        line_index += 1\n        if regex_field.match(line) or regex_termination.match(line) or regex_field_abbr.match(line):\n            new_line = line\n            while line_index &lt; len_data:\n                line = block[line_index]\n                if regex_field.match(line) or regex_termination.match(line) or regex_field_abbr.match(line):\n                    break\n                else:\n                    if line.lstrip():\n                        new_line = new_line.rstrip() + \" \" + line.lstrip()  # append\n                    line_index += 1\n            new_block.append(new_line)\n        else:\n            new_block.append(line)\n    return new_block\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.CheckEntry","title":"CheckEntry","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.CheckEntry-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.CheckEntry.check","title":"check  <code>staticmethod</code>","text":"<pre><code>check(field_list, brace_or_quote, block)\n</code></pre> <p>Check.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_entry_block.py</code> <pre><code>@staticmethod\ndef check(\n    field_list: list[str], brace_or_quote: tuple[str, str], block: list[str]\n) -&gt; tuple[dict[str, list[str]], list[str], bool]:\n    \"\"\"Check.\"\"\"\n    pre, post = brace_or_quote\n\n    regex_entry = re.compile(r\"\\s*@[a-zA-Z]+{\")\n    regex_field = re.compile(rf\"\\s*(?:{'|'.join(field_list)})\" + r\"\\s*=\")\n    entry_flag, brace_flag = False, False  # minimal conditions\n    error_dict: dict[str, list[str]] = {}\n    new_block = []\n    for line in block:\n        if regex_entry.match(line) and (not entry_flag):  # just iff exsiting one time in single patch bib\n            if (line.count(\"{\") != 1) or (line.count(\",\") != 1):\n                error_dict.setdefault(\"Failed entry_type\", []).append(line)\n            else:\n                entry_flag = True\n                new_block.append(line)\n\n        elif regex_field.match(line):\n            new_block.append(add_brace_or_quote(pre, post, line))\n\n        elif (line.strip() == \"}\") and (not brace_flag):  # just iff exsiting one time in single patch bib\n            brace_flag = True\n            new_block.append(line)\n\n        else:\n            error_dict.setdefault(\"Redundant content`\", []).append(line)\n    return error_dict, new_block, entry_flag and brace_flag\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.EntryBase","title":"EntryBase","text":"<pre><code>EntryBase()\n</code></pre> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_entry_block.py</code> <pre><code>def __init__(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.EntryBase-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.EntryBase.obtain_braces_or_quotes","title":"obtain_braces_or_quotes  <code>staticmethod</code>","text":"<pre><code>obtain_braces_or_quotes(block)\n</code></pre> <p>Obtain braces or quotes in block.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>list[str]</code> <p>block.</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str, str]: the tuple of braces or quotes.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_entry_block.py</code> <pre><code>@staticmethod\ndef obtain_braces_or_quotes(block: list[str]) -&gt; tuple[str, str]:\n    \"\"\"Obtain braces or quotes in block.\n\n    Args:\n        block (list[str]): block.\n\n    Returns:\n        tuple[str, str]: the tuple of braces or quotes.\n    \"\"\"\n    content = \"\".join(block)\n    regex_list = [\n        re.compile(r'\\btitles*\\s*=\\s*([{\"])', flags=re.I),\n        re.compile(r'\\bauthors*\\s*=\\s*([{\"])', flags=re.I),\n        re.compile(r'\\byears*\\s*=\\s*([{\"])', flags=re.I),\n        re.compile(r'\\bpages*\\s*=\\s*([{\"])', flags=re.I),\n        re.compile(r'\\burls*\\s*=\\s*([{\"])', flags=re.I),\n    ]\n    flag_list_list = [sorted(set(regex.findall(content))) for regex in regex_list]\n\n    flag_list_list = [f for f in flag_list_list if len(f) != 0]\n    len_list = [len(f) for f in flag_list_list]\n\n    # 0 or 1 or 2 flags\n    if (len(len_list) == 0) or (2 in len_list) or (not all(f == flag_list_list[0] for f in flag_list_list)):\n        return \"\", \"\"\n\n    if flag_list_list[0][0] == \"{\":\n        return \"{\", \"}\"\n    else:\n        return '\"', '\"'\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.EntryBase.obtain_fields","title":"obtain_fields","text":"<pre><code>obtain_fields(\n    block, default_fields_list, field_pattern=\"[\\\\w\\\\-]+\"\n)\n</code></pre> <p>Obtain fileds in block.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>list[str]</code> <p>block.</p> required <code>field_pattern</code> <code>str = r'[\\w\\-]+'</code> <p>field pattern.</p> <code>'[\\\\w\\\\-]+'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: field list.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_entry_block.py</code> <pre><code>def obtain_fields(\n    self, block: list[str], default_fields_list: list[str], field_pattern: str = r\"[\\w\\-]+\"\n) -&gt; list[str]:\n    r\"\"\"Obtain fileds in block.\n\n    Args:\n        block (list[str]): block.\n        field_pattern (str = r'[\\w\\-]+'): field pattern.\n\n    Returns:\n        list[str]: field list.\n    \"\"\"\n    regex = re.compile(rf\"({field_pattern})\\s*=\\s*(?:{'|'.join(FIELD_FORMAT_FLAG)})\")  # support for abbreviation\n    obtain_field_list = list(set(regex.findall(\"\".join(block))))\n    obtain_field_list = [field for field in obtain_field_list if field.lower() in default_fields_list]\n    return sorted(obtain_field_list)\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.ExtractEntry","title":"ExtractEntry","text":"<pre><code>ExtractEntry()\n</code></pre> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_entry_block.py</code> <pre><code>def __init__(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.ExtractEntry-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.ExtractEntry.extract","title":"extract","text":"<pre><code>extract(field_list, brace_or_quote, block)\n</code></pre> <p>Extract.</p> <p>Parameters:</p> Name Type Description Default <code>field_list</code> <code>list[str]</code> <p>field list</p> required <code>brace_or_quote</code> <code>tuple[str, str]</code> <p>(\", \") or ({, })</p> required <code>block</code> <code>list[str]</code> <p>the block</p> required Return <p>tuple[list[str], list[str]]: main block, redundant part</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_entry_block.py</code> <pre><code>def extract(\n    self, field_list: list[str], brace_or_quote: tuple[str, str], block: list[str]\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Extract.\n\n    Args:\n        field_list (list[str]): field list\n        brace_or_quote (tuple[str, str]): (\", \") or ({, })\n        block (list[str]): the block\n\n    Return:\n        tuple[list[str], list[str]]: main block, redundant part\n    \"\"\"\n    pre, post = brace_or_quote\n\n    temp = rf\"[%\\s]*(?:{'|'.join(field_list)})\"\n    regex_field_two = re.compile(rf\"({temp}\\s*=\\s*{pre})(.*)(\\n*)\", flags=re.I)\n    regex_field_one = re.compile(rf\"({temp}\\s*=\\s*{pre}.*{post})(.*)(\\n*)\", flags=re.I)\n    regex_field_abbr = re.compile(rf\"({temp}\\s*=\\s*\\w+[\\w\\-]*)(.*)(\\n*)\", flags=re.I)\n    regex_termination = re.compile(r\"(\\s*@[a-zA-Z]*{\\s*[\\w\\-:/\\\\.\\']*)(.*)(\\n*)\", flags=re.I)\n\n    main_list, redundant_list = [], []\n\n    for line in block:\n        new_line, redundant = \"\", \"\"\n        if mch := regex_termination.match(line):\n            one, two, three = mch.groups()\n            new_line = one + \",\\n\"\n            if re.sub(r\"[\\s,\\n\\}]+\", \"\", two):\n                redundant = two + three\n\n        elif mch := regex_field_abbr.match(line):\n            one, two, three = mch.groups()\n            new_line = one + \",\\n\"\n            if re.sub(r\"[\\s,\\n\\}]+\", \"\", two):\n                redundant = two + three\n\n        elif mch := regex_field_one.match(line):\n            one, two, three = mch.groups()\n            new_line = self._resub_brace_or_quote(pre, post, one + \",\\n\")\n            if re.sub(r\"[\\s,\\n\\}]+\", \"\", two):\n                redundant = two + three\n\n        elif mch := regex_field_two.match(line):\n            one, two, three = mch.groups()\n            new_line = self._resub_brace_or_quote(pre, post, one + two.strip() + post + \",\\n\")\n\n        elif line.strip() == \"}\":\n            pass\n\n        else:\n            return [], block\n\n        if new_line:\n            main_list.append(new_line)\n        if redundant:\n            redundant_list.append(redundant)\n\n    # for enclosing \"@[a-zA-Z]{\"\n    if main_list:\n        main_list.append(\"}\\n\")\n    return main_list, redundant_list\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block.StandardizeEntryBlock","title":"StandardizeEntryBlock","text":"<pre><code>StandardizeEntryBlock(default_additional_field_list=None)\n</code></pre> <p>Stanndardize entry block.</p> <p>Parameters:</p> Name Type Description Default <code>default_additional_field_list</code> <code>list[str] | None = None</code> <p>Additional default fields.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>default_fields_list</code> <code>list[str]</code> <p>Default fields.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_entry_block.py</code> <pre><code>def __init__(self, default_additional_field_list: list[str] | None = None) -&gt; None:\n    if default_additional_field_list is None:\n        default_additional_field_list = []\n\n    default_fields_old = [d.lower().strip() for d in DEFAULT_FIELDS_LIST]\n    default_fields_new = [d.lower().strip() for d in default_additional_field_list]\n    self.default_fields_list = list(set(default_fields_old).union(set(default_fields_new)))\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_entry_block/#pybibtexer.bib.bibtexbase.standardize.do_on_entry_block-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_preamble_block/","title":"bib.bibtexbase.standardize.do_on_preamble_block","text":"<p>Preamble block standardization utilities.</p> <p>This module provides functionality for processing and standardizing BibTeX preamble blocks. Preamble blocks contain LaTeX commands and definitions that are used throughout the BibTeX file.</p> <p>Classes:</p> Name Description <code>StandardizePreambleBlock</code> <p>Handles the standardization of @preamble blocks, ensuring proper quote matching and formatting of LaTeX commands.</p>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_preamble_block/#pybibtexer.bib.bibtexbase.standardize.do_on_preamble_block-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_preamble_block/#pybibtexer.bib.bibtexbase.standardize.do_on_preamble_block.StandardizePreambleBlock","title":"StandardizePreambleBlock","text":"<pre><code>StandardizePreambleBlock()\n</code></pre> <p>Stanndardize preamble block.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_preamble_block.py</code> <pre><code>def __init__(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_string_block/","title":"bib.bibtexbase.standardize.do_on_string_block","text":"<p>String block standardization utilities.</p> <p>This module provides functionality for processing and standardizing BibTeX string blocks. String blocks define abbreviations and macros that can be used throughout the BibTeX file to maintain consistency and reduce redundancy.</p> <p>Classes:</p> Name Description <code>StandardizeStringBlock</code> <p>Handles the standardization of @string blocks, ensuring proper delimiter matching and formatting of string definitions.</p>"},{"location":"api-auto/bib.bibtexbase.standardize.do_on_string_block/#pybibtexer.bib.bibtexbase.standardize.do_on_string_block-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexbase.standardize.do_on_string_block/#pybibtexer.bib.bibtexbase.standardize.do_on_string_block.StandardizeStringBlock","title":"StandardizeStringBlock","text":"<pre><code>StandardizeStringBlock()\n</code></pre> <p>Stanndardize string block.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize/do_on_string_block.py</code> <pre><code>def __init__(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize_bib/","title":"bib.bibtexbase.standardize_bib","text":"<p>Main BibTeX standardization module.</p> <p>This module provides the primary interface for standardizing BibTeX files. It coordinates the processing of different block types (entries, comments, preamble, and strings) and provides a unified standardization workflow.</p> <p>The StandardizeBib class serves as the main entry point for BibTeX standardization, handling the complete processing pipeline from raw BibTeX data to standardized output with comprehensive error reporting.</p> Constants <p>MARKS_FLAGS: Mapping of BibTeX entry types to their processing flags     and abbreviations for standardized output.</p> <p>Classes:</p> Name Description <code>StandardizeBib</code> <p>Main standardization class that processes complete BibTeX files and returns standardized output with error reporting.</p>"},{"location":"api-auto/bib.bibtexbase.standardize_bib/#pybibtexer.bib.bibtexbase.standardize_bib-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexbase.standardize_bib/#pybibtexer.bib.bibtexbase.standardize_bib.StandardizeBib","title":"StandardizeBib","text":"<pre><code>StandardizeBib(default_additional_field_list=None)\n</code></pre> <p>Stanndardize bib.</p> <p>Parameters:</p> Name Type Description Default <code>default_additional_field_list</code> <code>list[str] | None = None</code> <p>Additional default fields.</p> <code>None</code> Source code in <code>pybibtexer/bib/bibtexbase/standardize_bib.py</code> <pre><code>def __init__(self, default_additional_field_list: list[str] | None = None) -&gt; None:\n    self._standardize_comment_block = StandardizeCommentBlock()\n    self._standardize_entry_block = StandardizeEntryBlock(default_additional_field_list)\n    self._standardize_preamble_block = StandardizePreambleBlock()\n    self._standardize_string_block = StandardizeStringBlock()\n</code></pre>"},{"location":"api-auto/bib.bibtexbase.standardize_bib/#pybibtexer.bib.bibtexbase.standardize_bib.StandardizeBib-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexbase.standardize_bib/#pybibtexer.bib.bibtexbase.standardize_bib.StandardizeBib.standardize","title":"standardize","text":"<pre><code>standardize(data_list)\n</code></pre> <p>Generate standard bib.</p> <p>Parameters:</p> Name Type Description Default <code>data_list</code> <code>list[str]</code> <p>Bib data.</p> required <p>Returns:</p> Type Description <code>tuple[list[str], list[list[str]]]</code> <p>list[str]: Standard bib.</p> Source code in <code>pybibtexer/bib/bibtexbase/standardize_bib.py</code> <pre><code>def standardize(self, data_list: list[str]) -&gt; tuple[list[str], list[list[str]]]:\n    \"\"\"Generate standard bib.\n\n    Args:\n        data_list (list[str]): Bib data.\n\n    Returns:\n        list[str]: Standard bib.\n    \"\"\"\n    # Initialize\n    data_list = \"\".join(data_list).splitlines(keepends=True)\n    data_list = [line for line in data_list if line.strip()]\n\n    # Split data according to mark pattern\n    data_list = SplitBibAccordingToMark().split_marks(data_list)\n\n    new_data_list: list[str] = []\n    implicit_comment_list: list[list[str]] = []\n\n    # Generate dict\n    mark_blocks_dict, temp_implicit_comment_list = ObtainMarkBlocksDict().obtain_dict(data_list, True)\n    implicit_comment_list.extend(temp_implicit_comment_list)\n\n    marks, flags = [i[0] for i in MARKS_FLAGS], [i[1] for i in MARKS_FLAGS]\n    if not_in := {k: v for k, v in mark_blocks_dict.items() if k not in marks}:\n        print(f\"Warning: Not standard parts - {not_in}\")\n\n    for mark in mark_blocks_dict:\n        if mark in marks:\n            flag = flags[marks.index(mark)]\n\n            for block in mark_blocks_dict[mark]:\n                block, temp = eval(f\"self._standardize_{flag}_block.standardize\")(block)\n                new_data_list.extend(block)\n                implicit_comment_list.extend(temp)\n\n    return new_data_list, implicit_comment_list\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.bibtex_format/","title":"bib.bibtexparser.bibtex_format","text":""},{"location":"api-auto/bib.bibtexparser.bibtex_format/#pybibtexer.bib.bibtexparser.bibtex_format-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.bibtex_format/#pybibtexer.bib.bibtexparser.bibtex_format.BibtexFormat","title":"BibtexFormat","text":"<pre><code>BibtexFormat()\n</code></pre> <p>Definition of formatting (alignment, ...) when writing a BibTeX file.</p> For more manual, GUI-based formatting, see the <code>bibtex-tidy</code> tool: <p>https://flamingtempura.github.io/bibtex-tidy/</p> Source code in <code>pybibtexer/bib/bibtexparser/bibtex_format.py</code> <pre><code>def __init__(self):\n    self._indent: str = \"  \"  # \"\\t\"\n    self._align_field_values: int | str = \"auto\"\n    self._block_separator: str = \"\"  # \"\\n\\n\"\n    self._trailing_comma: bool = True\n    self._parsing_failed_comment: str = PARSING_FAILED_COMMENT\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.bibtex_format/#pybibtexer.bib.bibtexparser.bibtex_format.BibtexFormat-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.bibtex_format/#pybibtexer.bib.bibtexparser.bibtex_format.BibtexFormat.block_separator","title":"block_separator  <code>property</code> <code>writable</code>","text":"<pre><code>block_separator\n</code></pre> <p>Character(s) for separating BibTeX entries.</p> <p>Default: Two lines breaks, i.e., two blank lines.</p>"},{"location":"api-auto/bib.bibtexparser.bibtex_format/#pybibtexer.bib.bibtexparser.bibtex_format.BibtexFormat.indent","title":"indent  <code>property</code> <code>writable</code>","text":"<pre><code>indent\n</code></pre> <p>Character(s) for indenting BibTeX field-value pairs. Default: single space.</p>"},{"location":"api-auto/bib.bibtexparser.bibtex_format/#pybibtexer.bib.bibtexparser.bibtex_format.BibtexFormat.parsing_failed_comment","title":"parsing_failed_comment  <code>property</code> <code>writable</code>","text":"<pre><code>parsing_failed_comment\n</code></pre> <p>Comment to use for blocks that could not be parsed.</p>"},{"location":"api-auto/bib.bibtexparser.bibtex_format/#pybibtexer.bib.bibtexparser.bibtex_format.BibtexFormat.trailing_comma","title":"trailing_comma  <code>property</code> <code>writable</code>","text":"<pre><code>trailing_comma\n</code></pre> <p>Use the trailing comma syntax for BibTeX entries. Default: True.</p> <p>BibTeX syntax allows an optional comma at the end of the last field in an entry.</p>"},{"location":"api-auto/bib.bibtexparser.bibtex_format/#pybibtexer.bib.bibtexparser.bibtex_format.BibtexFormat.value_column","title":"value_column  <code>property</code> <code>writable</code>","text":"<pre><code>value_column\n</code></pre> <p>Controls the alignment of field- and string-values. Default: no alignment.</p> <p>This impacts String and Entry blocks.</p> <p>An integer value x specifies that spaces should be added before the \" = \", such that, if possible, the value is written at column <code>len(self.indent) + x</code>. Note that for long keys, the value may be written at a later column.</p> <p>Thus, a value of 0 means that the value is written directly after the \" = \".</p> <p>The special value \"auto\" specifies that the bibtex field value should be aligned based on the longest key in the library.</p>"},{"location":"api-auto/bib.bibtexparser.exceptions/","title":"bib.bibtexparser.exceptions","text":""},{"location":"api-auto/bib.bibtexparser.exceptions/#pybibtexer.bib.bibtexparser.exceptions-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.exceptions/#pybibtexer.bib.bibtexparser.exceptions.BlockAbortedException","title":"BlockAbortedException","text":"<pre><code>BlockAbortedException(abort_reason, end_index=None)\n</code></pre> <p>               Bases: <code>ParsingException</code></p> <p>Exception where a invalid bibtex file led to an aborted block.</p> Source code in <code>pybibtexer/bib/bibtexparser/exceptions.py</code> <pre><code>def __init__(\n    self,\n    abort_reason: str,\n    # Not provided if end of file is reached\n    end_index: int | None = None,\n):\n    self.abort_reason = abort_reason\n    self.end_index = end_index\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.exceptions/#pybibtexer.bib.bibtexparser.exceptions.ParserStateException","title":"ParserStateException","text":"<pre><code>ParserStateException(message)\n</code></pre> <p>               Bases: <code>ParsingException</code></p> <p>Parser is in a self-inflicted invalid state.</p> Source code in <code>pybibtexer/bib/bibtexparser/exceptions.py</code> <pre><code>def __init__(self, message: str):\n    self.message = message\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.exceptions/#pybibtexer.bib.bibtexparser.exceptions.ParsingException","title":"ParsingException","text":"<p>               Bases: <code>Exception</code></p> <p>Generic Exception for parsing errors.</p>"},{"location":"api-auto/bib.bibtexparser.exceptions/#pybibtexer.bib.bibtexparser.exceptions.PartialMiddlewareException","title":"PartialMiddlewareException","text":"<pre><code>PartialMiddlewareException(reasons)\n</code></pre> <p>               Bases: <code>ParsingException</code></p> <p>Exception raised when a middleware could not be fully applied.</p> Source code in <code>pybibtexer/bib/bibtexparser/exceptions.py</code> <pre><code>def __init__(self, reasons: list[str]):\n    reasons_string = \"\\n\\n=====\\n\\n\".join(reasons)\n    super().__init__(f\"Middleware could not be fully applied: {reasons_string}\")\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.exceptions/#pybibtexer.bib.bibtexparser.exceptions.RegexMismatchException","title":"RegexMismatchException","text":"<pre><code>RegexMismatchException(\n    first_match, expected_match, second_match\n)\n</code></pre> <p>               Bases: <code>ParserStateException</code></p> <p>Raised when regex matches are inconsistent, implying a bug in the parser.</p> <p>For example, raised when first match <code>@string{</code> is not followed by an overlapping match <code>}</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/exceptions.py</code> <pre><code>def __init__(self, first_match, expected_match, second_match):\n    self.first_match = first_match\n    self.expected_match = expected_match\n    self.second_match = second_match\n    super().__init__(\n        f\"Regex mismatch: {first_match} followed by {second_match},\"\n        f\"but expected {expected_match}.\\n\"\n        \"This is an python-bibtexparser internal error. \"\n        \"Please report this issue at our issue tracker.\"\n    )\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.library/","title":"bib.bibtexparser.library","text":""},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library","title":"Library","text":"<pre><code>Library(blocks=None)\n</code></pre> <p>A collection of parsed bibtex blocks.</p> Source code in <code>pybibtexer/bib/bibtexparser/library.py</code> <pre><code>def __init__(self, blocks: list[Block] | None = None):\n    self._blocks = []\n    self._entries_by_key = {}\n    self._strings_by_key = {}\n    if blocks is not None:\n        self.add(blocks)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.blocks","title":"blocks  <code>property</code>","text":"<pre><code>blocks\n</code></pre> <p>All blocks in the library, preserving order of insertion.</p>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.comments","title":"comments  <code>property</code>","text":"<pre><code>comments\n</code></pre> <p>All comment blocks in the library, preserving order of insertion.</p>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.entries","title":"entries  <code>property</code>","text":"<pre><code>entries\n</code></pre> <p>All entry (@article, ...) blocks in the library, preserving order of insertion.</p>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.entries_dict","title":"entries_dict  <code>property</code>","text":"<pre><code>entries_dict\n</code></pre> <p>Dict representation of all entry blocks in the library.</p>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.failed_blocks","title":"failed_blocks  <code>property</code>","text":"<pre><code>failed_blocks\n</code></pre> <p>All blocks that could not be parsed, preserving order of insertion.</p>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.preambles","title":"preambles  <code>property</code>","text":"<pre><code>preambles\n</code></pre> <p>All @preamble blocks in the library, preserving order of insertion.</p>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.strings","title":"strings  <code>property</code>","text":"<pre><code>strings\n</code></pre> <p>All @string blocks in the library, preserving order of insertion.</p>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.strings_dict","title":"strings_dict  <code>property</code>","text":"<pre><code>strings_dict\n</code></pre> <p>Dict representation of all @string blocks in the library.</p>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.add","title":"add","text":"<pre><code>add(blocks, fail_on_duplicate_key=False)\n</code></pre> <p>Add blocks to library.</p> <p>The adding is key-safe, i.e., it is made sure that no duplicate keys are added. for the same type (i.e., String or Entry). Duplicates are silently replaced with a DuplicateKeyBlock.</p> <p>:param blocks: Block or list of blocks to add. :param fail_on_duplicate_key:     If True, raises ValueError if a block was replaced with a DuplicateKeyBlock.</p> Source code in <code>pybibtexer/bib/bibtexparser/library.py</code> <pre><code>def add(self, blocks: list[Block] | Block, fail_on_duplicate_key: bool = False):\n    \"\"\"Add blocks to library.\n\n    The adding is key-safe, i.e., it is made sure that no duplicate keys are added.\n    for the same type (i.e., String or Entry). Duplicates are silently replaced with\n    a DuplicateKeyBlock.\n\n    :param blocks: Block or list of blocks to add.\n    :param fail_on_duplicate_key:\n        If True, raises ValueError if a block was replaced with a DuplicateKeyBlock.\n    \"\"\"\n    if isinstance(blocks, Block):\n        blocks = [blocks]\n\n    _added_blocks = []\n    for block in blocks:\n        # This may replace block with a DuplicateEntryKeyBlock\n        block = self._add_to_dicts(block)\n        self._blocks.append(block)\n        _added_blocks.append(block)\n\n    if fail_on_duplicate_key:\n        duplicate_keys = []\n        for original, added in zip(blocks, _added_blocks, strict=True):\n            if original is not added and isinstance(added, DuplicateBlockKeyBlock):\n                duplicate_keys.append(added.key)\n\n        if len(duplicate_keys) &gt; 0:\n            raise ValueError(\n                f\"Duplicate keys found: {duplicate_keys}. \"\n                f\"Duplicate entries have been added to the library as DuplicateBlockKeyBlock.\"\n                f\"Use `library.failed_blocks` to access them. \"\n            )\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.convert","title":"convert","text":"<pre><code>convert(name)\n</code></pre> <p>Convert the library to special library.</p> <p>Convert the library to special library only contain block whose name is <code>name</code>, such as <code>entry</code>, 'string', ...</p> Source code in <code>pybibtexer/bib/bibtexparser/library.py</code> <pre><code>def convert(self, name: str):\n    \"\"\"Convert the library to special library.\n\n    Convert the library to special library only contain block\n    whose name is `name`, such as `entry`, 'string', ...\n    \"\"\"\n    for block in self._blocks:\n        if block.__class__.__name__.lower() != name.lower():\n            self.remove(block)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.remove","title":"remove","text":"<pre><code>remove(blocks)\n</code></pre> <p>Remove blocks from library.</p> <p>:param blocks: Block or list of blocks to remove. :raises ValueError: If block is not in library.</p> Source code in <code>pybibtexer/bib/bibtexparser/library.py</code> <pre><code>def remove(self, blocks: list[Block] | Block):\n    \"\"\"Remove blocks from library.\n\n    :param blocks: Block or list of blocks to remove.\n    :raises ValueError: If block is not in library.\n    \"\"\"\n    if isinstance(blocks, Block):\n        blocks = [blocks]\n\n    for block in blocks:\n        self._blocks.remove(block)\n        if isinstance(block, Entry):\n            del self._entries_by_key[block.key]\n        elif isinstance(block, String):\n            del self._strings_by_key[block.key]\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.library/#pybibtexer.bib.bibtexparser.library.Library.replace","title":"replace","text":"<pre><code>replace(old_block, new_block, fail_on_duplicate_key=True)\n</code></pre> <p>Replace a block with another block, at the same position.</p> <p>:param old_block: Block to replace. :param new_block: Block to replace with. :param fail_on_duplicate_key: If False, adds a DuplicateKeyBlock if         a block with new_block.key (other than old_block) already exists. :raises ValueError: If old_block is not in library or if fail_on_duplicate_key is True         and a block with new_block.key (other than old_block) already exists.</p> Source code in <code>pybibtexer/bib/bibtexparser/library.py</code> <pre><code>def replace(self, old_block: Block, new_block: Block, fail_on_duplicate_key: bool = True):\n    \"\"\"Replace a block with another block, at the same position.\n\n    :param old_block: Block to replace.\n    :param new_block: Block to replace with.\n    :param fail_on_duplicate_key: If False, adds a DuplicateKeyBlock if\n            a block with new_block.key (other than old_block) already exists.\n    :raises ValueError: If old_block is not in library or if fail_on_duplicate_key is True\n            and a block with new_block.key (other than old_block) already exists.\n    \"\"\"\n    try:\n        index = self._blocks.index(old_block)\n        self.remove(old_block)\n    except ValueError:\n        raise ValueError(\"Block to replace is not in library.\")\n\n    block_after_add = self._add_to_dicts(new_block)\n    self._blocks.insert(index, block_after_add)\n\n    if (\n        new_block is not block_after_add\n        and isinstance(block_after_add, DuplicateBlockKeyBlock)\n        and fail_on_duplicate_key\n    ):\n        # Revert changes to old_block\n        #   Don't fail on duplicate key, as this would lead to an infinite recursion\n        #   (should never happen for a clean library, but could happen if the user\n        #   tampered with the internals of the library).\n        self.replace(block_after_add, old_block, fail_on_duplicate_key=False)\n        raise ValueError(\"Duplicate key found.\")\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.add_field/","title":"bib.bibtexparser.middlewares.block.add_field","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.add_field/#pybibtexer.bib.bibtexparser.middlewares.block.add_field-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.add_field/#pybibtexer.bib.bibtexparser.middlewares.block.add_field.AddArchive","title":"AddArchive","text":"<pre><code>AddArchive(\n    abbr_article_pattern_dict,\n    abbr_inproceedings_pattern_dict,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Add Field <code>archive</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/add_field.py</code> <pre><code>def __init__(\n    self,\n    abbr_article_pattern_dict: dict,\n    abbr_inproceedings_pattern_dict: dict,\n    allow_inplace_modification: bool = True,\n):\n    super().__init__(allow_inplace_modification=allow_inplace_modification)\n\n    self.abbr_article_pattern_dict = abbr_article_pattern_dict\n    self.abbr_inproceedings_pattern_dict = abbr_inproceedings_pattern_dict\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.add_field/#pybibtexer.bib.bibtexparser.middlewares.block.add_field.AddJournalLongAbbr","title":"AddJournalLongAbbr","text":"<pre><code>AddJournalLongAbbr(\n    full_abbr_article_dict,\n    full_names_in_json,\n    abbr_names_in_json,\n    abbr_article_pattern_dict,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Add long abbr for field <code>journal</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/add_field.py</code> <pre><code>def __init__(\n    self,\n    full_abbr_article_dict: dict,\n    full_names_in_json: str,\n    abbr_names_in_json: str,\n    abbr_article_pattern_dict: dict,\n    allow_inplace_modification: bool = True,\n):\n    super().__init__(allow_inplace_modification=allow_inplace_modification)\n\n    self.full_abbr_article_dict = full_abbr_article_dict\n    self.full_names_in_json = full_names_in_json\n    self.abbr_names_in_json = abbr_names_in_json\n    self.abbr_article_pattern_dict = abbr_article_pattern_dict\n    self.abbr_inproceedings_pattern_dict = {}\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.authors/","title":"bib.bibtexparser.middlewares.block.authors","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.authors/#pybibtexer.bib.bibtexparser.middlewares.block.authors-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.authors/#pybibtexer.bib.bibtexparser.middlewares.block.authors.ConstrainNumberOfAuthors","title":"ConstrainNumberOfAuthors","text":"<pre><code>ConstrainNumberOfAuthors(\n    maximum_authors, allow_inplace_modification=True\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Constrain the number of authors.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/authors.py</code> <pre><code>def __init__(self, maximum_authors: int, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n\n    self.maximum_authors = maximum_authors\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.doi_url/","title":"bib.bibtexparser.middlewares.block.doi_url","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.doi_url/#pybibtexer.bib.bibtexparser.middlewares.block.doi_url-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.doi_url/#pybibtexer.bib.bibtexparser.middlewares.block.doi_url.ChangeDoiToUrlInEntry","title":"ChangeDoiToUrlInEntry","text":"<pre><code>ChangeDoiToUrlInEntry(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Chang doi to url by add <code>https://doi.org/</code> if not existed, and then delete doi.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/doi_url.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.doi_url/#pybibtexer.bib.bibtexparser.middlewares.block.doi_url.ChooseDoiOrUrlInEntry","title":"ChooseDoiOrUrlInEntry","text":"<pre><code>ChooseDoiOrUrlInEntry(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Choose doi when an item has both a doi and a url.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/doi_url.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.doi_url/#pybibtexer.bib.bibtexparser.middlewares.block.doi_url.HttpsUrlInEntry","title":"HttpsUrlInEntry","text":"<pre><code>HttpsUrlInEntry(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Change http to https for security.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/doi_url.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.doi_url/#pybibtexer.bib.bibtexparser.middlewares.block.doi_url.SimplifyDoiInEntry","title":"SimplifyDoiInEntry","text":"<pre><code>SimplifyDoiInEntry(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Simplify doi by delete <code>https://doi.org/</code> if existed.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/doi_url.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_keys_normalize/","title":"bib.bibtexparser.middlewares.block.entry_field_keys_normalize","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_keys_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_keys_normalize-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_keys_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_keys_normalize.NormalizeEntryFieldKeys","title":"NormalizeEntryFieldKeys","text":"<pre><code>NormalizeEntryFieldKeys(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Normalize field keys to lowercase.</p> <p>In case of conflicts (e.g. both 'author' and 'Author' exist in the same entry), a warning is emitted, and the last value wins.</p> <p>Some other middlewares, such as <code>SeparateCoAuthors</code>, assume lowercase key names.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_keys_normalize.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_keys_replace/","title":"bib.bibtexparser.middlewares.block.entry_field_keys_replace","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_keys_replace/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_keys_replace-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_keys_replace/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_keys_replace.ReplaceFieldKeyInEntry","title":"ReplaceFieldKeyInEntry","text":"<pre><code>ReplaceFieldKeyInEntry(\n    entry_type,\n    old_field_keys,\n    new_field_keys,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Replace field key by user.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_keys_replace.py</code> <pre><code>def __init__(\n    self,\n    entry_type: str,\n    old_field_keys: list[str],\n    new_field_keys: list[str],\n    allow_inplace_modification: bool = True,\n):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n\n    self.entry_type = entry_type\n    self.old_field_keys = old_field_keys\n    self.new_field_keys = new_field_keys\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/","title":"bib.bibtexparser.middlewares.block.entry_field_values_normalize","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize.AddUrlToFieldValueInEntry","title":"AddUrlToFieldValueInEntry","text":"<pre><code>AddUrlToFieldValueInEntry(\n    field_key, allow_inplace_modification=True\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Add url link to title.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_values_normalize.py</code> <pre><code>def __init__(self, field_key: str, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n\n    self.field_key = field_key\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize.NormalizeEntryFieldValues","title":"NormalizeEntryFieldValues","text":"<pre><code>NormalizeEntryFieldValues(\n    field_keys=[\"journal\", \"booktitle\"],\n    title_lower_upper=\"upper\",\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Normalize some field values (journal and booktitle) to upper case.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_values_normalize.py</code> <pre><code>def __init__(\n    self,\n    field_keys: list[str] = [\"journal\", \"booktitle\"],\n    title_lower_upper: str = \"upper\",\n    allow_inplace_modification: bool = True,\n):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n\n    self._field_keys = field_keys\n    self.title_lower_upper = title_lower_upper\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize.NormalizeFieldValuesInEntry","title":"NormalizeFieldValuesInEntry","text":"<pre><code>NormalizeFieldValuesInEntry(\n    field_key,\n    sentence_title,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Sentence field values.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_values_normalize.py</code> <pre><code>def __init__(self, field_key: str, sentence_title: str, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n\n    self.field_key = field_key\n    self.sentence_title = sentence_title\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize.NormalizeFieldValuesInEntry-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize.NormalizeFieldValuesInEntry.__generate_new_case_title","title":"__generate_new_case_title","text":"<pre><code>__generate_new_case_title(old_title, flag)\n</code></pre> <p>Generate new title.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_values_normalize.py</code> <pre><code>def __generate_new_case_title(self, old_title: str, flag: str) -&gt; str:\n    \"\"\"Generate new title.\"\"\"\n    old_list, new_list = re.split(r\"\\s+\", old_title), []\n    for i in range(len(old_list)):\n        old_str = old_list[i]\n        if re.search(r\"-\", old_str):\n            temp_list, new_temp_list = re.split(\"-\", old_str), []\n            if i == 0:  # for the first element\n                new_temp_list = [self.__upper_or_lower_first_letter(temp_list[0], \"upper\")]\n                temp_list = temp_list[1:]\n            for t in temp_list:\n                if len(t.strip()) == 1:\n                    new_temp_list.append(t)  # not change\n                else:\n                    if flag == \"sentence\":\n                        new_temp_list.append(self.__lower_first_letter_and_others_not_contain_uppers(t))\n                    elif flag == \"title\":\n                        new_temp_list.append(self.__upper_first_letter_and_others_not_contain_uppers(t))\n                    else:\n                        pass\n            new_list.append(\"-\".join(new_temp_list))\n        else:\n            if i == 0:\n                new_list.append(self.__upper_or_lower_first_letter(old_str, \"upper\"))\n            else:\n                if flag == \"sentence\":\n                    new_list.append(self.__lower_first_letter_and_others_not_contain_uppers(old_str))\n                elif flag == \"title\":\n                    new_list.append(self.__upper_first_letter_and_others_not_contain_uppers(old_str))\n                else:\n                    pass\n    return \" \".join(new_list)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize.NormalizeFieldValuesInEntry.__lower_first_letter_and_others_not_contain_uppers","title":"__lower_first_letter_and_others_not_contain_uppers","text":"<pre><code>__lower_first_letter_and_others_not_contain_uppers(\n    input_str,\n)\n</code></pre> <p>Lower.</p> <p>Input: About; A; $about; ABOUT; aBOUT Output: about; a; $about; ABOUT; aBOUT</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_values_normalize.py</code> <pre><code>def __lower_first_letter_and_others_not_contain_uppers(self, input_str: str) -&gt; str:\n    \"\"\"Lower.\n\n    Input: About; A; $about; ABOUT; aBOUT\n    Output: about; a; $about; ABOUT; aBOUT\n    \"\"\"\n    new_input_str = input_str.strip()\n    if new_input_str and (not re.search(r\"[A-Z]\", new_input_str[1:])):  # Others not contain upper letter\n        input_str = self.__upper_or_lower_first_letter(input_str, \"lower\")  # Lower\n    return input_str\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize.NormalizeFieldValuesInEntry.__upper_first_letter_and_others_not_contain_uppers","title":"__upper_first_letter_and_others_not_contain_uppers","text":"<pre><code>__upper_first_letter_and_others_not_contain_uppers(\n    input_str,\n)\n</code></pre> <p>Upper.</p> <p>Input: about; a; $about; ABOUT; abOUT Output: About; A; $about; ABOUT; abOUT</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_values_normalize.py</code> <pre><code>def __upper_first_letter_and_others_not_contain_uppers(self, input_str: str) -&gt; str:\n    \"\"\"Upper.\n\n    Input: about; a; $about; ABOUT; abOUT\n    Output: About; A; $about; ABOUT; abOUT\n    \"\"\"\n    new_input_str = input_str.strip()\n    if new_input_str.lower() in SKIP_WORD_IN_CITATION_KEY:\n        return new_input_str.lower()\n\n    if new_input_str and (not re.search(r\"[A-Z]\", new_input_str[1:])):  # Others not contain upper letter\n        input_str = self.__upper_or_lower_first_letter(input_str, \"upper\")  # upper\n    return input_str\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize.NormalizeFieldValuesInEntry.__upper_or_lower_first_letter","title":"__upper_or_lower_first_letter  <code>staticmethod</code>","text":"<pre><code>__upper_or_lower_first_letter(input_str, flag)\n</code></pre> <p>Upper or lower first letter.</p> <p>Check whether the first is in the a-zA-Z and then UPPER or LOWER it. flag = upper Input: about; $food; About; aBout Output: About; $food; About; ABout flag = lower Input: About; $food; about; ABout Output: about; $food; about; aBout</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_values_normalize.py</code> <pre><code>@staticmethod\ndef __upper_or_lower_first_letter(input_str: str, flag: str) -&gt; str:\n    \"\"\"Upper or lower first letter.\n\n    Check whether the first is in the a-zA-Z and then UPPER or LOWER it.\n    flag = upper\n    Input: about; $food; About; aBout\n    Output: About; $food; About; ABout\n    flag = lower\n    Input: About; $food; about; ABout\n    Output: about; $food; about; aBout\n    \"\"\"\n    new_input_str = input_str.strip()\n    if new_input_str and re.search(r\"[a-zA-Z]\", new_input_str[0]):\n        if flag == \"lower\":\n            new_input_str = new_input_str[0].lower() + new_input_str[1:]\n        elif flag == \"upper\":\n            new_input_str = new_input_str[0].upper() + new_input_str[1:]\n        else:\n            new_input_str = input_str\n    return new_input_str\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize.NormalizeFieldValuesInEntry.generate_standard_sentence_case","title":"generate_standard_sentence_case","text":"<pre><code>generate_standard_sentence_case(title_content)\n</code></pre> <p>Generate standard title.</p> <p>\"Hello, world\".upper() # HELLO WORLD \"HELLO, WORLD\".lower() # hello world \"hello, world\".capitalize() # Hello, world \"hello, world\".title() # Hello, World</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_values_normalize.py</code> <pre><code>def generate_standard_sentence_case(self, title_content: str) -&gt; str:\n    \"\"\"Generate standard title.\n\n    \"Hello, world\".upper() # HELLO WORLD\n    \"HELLO, WORLD\".lower() # hello world\n    \"hello, world\".capitalize() # Hello, world\n    \"hello, world\".title() # Hello, World\n    \"\"\"\n    return self._generate_standard_title(title_content, \"sentence\")\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_field_values_normalize/#pybibtexer.bib.bibtexparser.middlewares.block.entry_field_values_normalize.NormalizeFieldValuesInEntry.generate_standard_title_case","title":"generate_standard_title_case","text":"<pre><code>generate_standard_title_case(title_content)\n</code></pre> <p>Generate standard title.</p> <p>\"Hello, world\".upper() # HELLO WORLD \"HELLO, WORLD\".lower() # hello world \"hello, world\".capitalize() # Hello, world \"hello, world\".title() # Hello, World</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_field_values_normalize.py</code> <pre><code>def generate_standard_title_case(self, title_content: str) -&gt; str:\n    \"\"\"Generate standard title.\n\n    \"Hello, world\".upper() # HELLO WORLD\n    \"HELLO, WORLD\".lower() # hello world\n    \"hello, world\".capitalize() # Hello, world\n    \"hello, world\".title() # Hello, World\n    \"\"\"\n    return self._generate_standard_title(title_content, \"title\")\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_fields_delete/","title":"bib.bibtexparser.middlewares.block.entry_fields_delete","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_fields_delete/#pybibtexer.bib.bibtexparser.middlewares.block.entry_fields_delete-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_fields_delete/#pybibtexer.bib.bibtexparser.middlewares.block.entry_fields_delete.DeleteFieldsInEntry","title":"DeleteFieldsInEntry","text":"<pre><code>DeleteFieldsInEntry(\n    delete_field_keys,\n    entry_type=None,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Delete fields by user.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_fields_delete.py</code> <pre><code>def __init__(\n    self, delete_field_keys: list[str], entry_type: str | None = None, allow_inplace_modification: bool = True\n):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n\n    self.entry_type = entry_type\n    self.delete_field_keys = delete_field_keys\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_fields_keep/","title":"bib.bibtexparser.middlewares.block.entry_fields_keep","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_fields_keep/#pybibtexer.bib.bibtexparser.middlewares.block.entry_fields_keep-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_fields_keep/#pybibtexer.bib.bibtexparser.middlewares.block.entry_fields_keep.KeepFieldsInEntry","title":"KeepFieldsInEntry","text":"<pre><code>KeepFieldsInEntry(\n    entry_type,\n    keep_field_keys,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Keep the fields of an entry according to a custom list of field keys provided by user.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_fields_keep.py</code> <pre><code>def __init__(self, entry_type: str, keep_field_keys: list[str], allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n\n    self.entry_type = entry_type\n    self.keep_field_keys = keep_field_keys\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_fields_sort/","title":"bib.bibtexparser.middlewares.block.entry_fields_sort","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_fields_sort/#pybibtexer.bib.bibtexparser.middlewares.block.entry_fields_sort-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_fields_sort/#pybibtexer.bib.bibtexparser.middlewares.block.entry_fields_sort.SortFieldsAlphabeticallyMiddleware","title":"SortFieldsAlphabeticallyMiddleware","text":"<pre><code>SortFieldsAlphabeticallyMiddleware(\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Sort the fields of an entry alphabetically by key.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_fields_sort.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_fields_sort/#pybibtexer.bib.bibtexparser.middlewares.block.entry_fields_sort.SortFieldsCustomMiddleware","title":"SortFieldsCustomMiddleware","text":"<pre><code>SortFieldsCustomMiddleware(\n    order,\n    case_sensitive=False,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Sort the fields of an entry according to a custom order provided by user.</p> <p>The order is a list of field keys. Fields not in the list are put at the end.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_fields_sort.py</code> <pre><code>def __init__(self, order: tuple[str, ...], case_sensitive: bool = False, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n    self._case_sensitive = case_sensitive\n    if not case_sensitive:\n        self._order = [x.lower() for x in order]\n    else:\n        self._order = order\n\n    if len(self._order) != len(set(self._order)):\n        duplicate_keys = {x for x in self._order if self._order.count(x) &gt; 1}\n        raise ValueError(\n            \"Order list must not contain duplicates. \"\n            \"The following keys are duplicated: \"\n            f\"{', '.join(duplicate_keys)}\"\n        )\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_types/","title":"bib.bibtexparser.middlewares.block.entry_types","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_types/#pybibtexer.bib.bibtexparser.middlewares.block.entry_types-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.entry_types/#pybibtexer.bib.bibtexparser.middlewares.block.entry_types.NormalizeEntryTypes","title":"NormalizeEntryTypes","text":"<pre><code>NormalizeEntryTypes(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Normalize Entry types.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/entry_types.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.journal_booktitle/","title":"bib.bibtexparser.middlewares.block.journal_booktitle","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.journal_booktitle/#pybibtexer.bib.bibtexparser.middlewares.block.journal_booktitle-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.journal_booktitle/#pybibtexer.bib.bibtexparser.middlewares.block.journal_booktitle.AbbreviateJournalBooktitle","title":"AbbreviateJournalBooktitle","text":"<pre><code>AbbreviateJournalBooktitle(\n    full_abbr_article_dict,\n    full_abbr_inproceedings_dict,\n    abbr_index_article_for_abbr,\n    abbr_index_inproceedings_for_abbr,\n    full_names_in_json,\n    abbr_names_in_json,\n    abbr_article_pattern_dict,\n    abbr_inproceedings_pattern_dict,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Abbreviate the field <code>journal</code> or <code>booktitle</code> value of an entry.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/journal_booktitle.py</code> <pre><code>def __init__(\n    self,\n    full_abbr_article_dict: dict,\n    full_abbr_inproceedings_dict: dict,\n    abbr_index_article_for_abbr: int,\n    abbr_index_inproceedings_for_abbr: int,\n    full_names_in_json: str,\n    abbr_names_in_json: str,\n    abbr_article_pattern_dict: dict,\n    abbr_inproceedings_pattern_dict: dict,\n    allow_inplace_modification: bool = True,\n):\n    super().__init__(allow_inplace_modification=allow_inplace_modification)\n\n    self.full_abbr_article_dict = full_abbr_article_dict\n    self.full_abbr_inproceedings_dict = full_abbr_inproceedings_dict\n    self.abbr_index_article_for_abbr = abbr_index_article_for_abbr\n    self.abbr_index_inproceedings_for_abbr = abbr_index_inproceedings_for_abbr\n    self.full_names_in_json = full_names_in_json\n    self.abbr_names_in_json = abbr_names_in_json\n    self.abbr_article_pattern_dict = abbr_article_pattern_dict\n    self.abbr_inproceedings_pattern_dict = abbr_inproceedings_pattern_dict\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.journal_booktitle/#pybibtexer.bib.bibtexparser.middlewares.block.journal_booktitle.AbbreviateJournalBooktitle-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.journal_booktitle/#pybibtexer.bib.bibtexparser.middlewares.block.journal_booktitle.AbbreviateJournalBooktitle.abbreviate_journal_booktitle","title":"abbreviate_journal_booktitle","text":"<pre><code>abbreviate_journal_booktitle(entry, abbr)\n</code></pre> <p>Abbreviate.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/journal_booktitle.py</code> <pre><code>def abbreviate_journal_booktitle(self, entry: Entry, abbr: str) -&gt; Entry:\n    \"\"\"Abbreviate.\"\"\"\n    if entry.entry_type.lower() == \"article\":\n        field_key = \"journal\"\n        abbr_index = self.abbr_index_article_for_abbr\n        full_name_list = self.full_abbr_article_dict.get(abbr, {}).get(self.full_names_in_json, [])\n        long_abbr_name_list = self.full_abbr_article_dict.get(abbr, {}).get(self.abbr_names_in_json, [])\n    elif entry.entry_type.lower() == \"inproceedings\":\n        field_key = \"booktitle\"\n        abbr_index = self.abbr_index_inproceedings_for_abbr\n        full_name_list = self.full_abbr_inproceedings_dict.get(abbr, {}).get(self.full_names_in_json, [])\n        long_abbr_name_list = self.full_abbr_inproceedings_dict.get(abbr, {}).get(self.abbr_names_in_json, [])\n    else:\n        return entry\n\n    if abbr_index not in [1, 2]:\n        return entry\n\n    # Case 1\n    if abbr_index == 2:\n        entry[field_key] = abbr\n        return entry\n\n    # Case 2\n    field_content = entry[field_key] if field_key in entry else \"\"\n    field_content = re.sub(r\"\\(.*\\)\", \"\", field_content).strip()\n\n    if not field_content:\n        return entry\n\n    # match\n    content_list = []\n    if abbr_index == 1:\n        for full, long_abbr in zip(full_name_list, long_abbr_name_list, strict=True):\n            if re.match(f\"^{full}$\", field_content, re.I):\n                content_list.append(long_abbr)\n\n    # check\n    content_list = list(set(content_list))\n    if len(content_list) &gt; 1:\n        print(f\"Multiple match: {content_list} for {field_content}.\")\n    elif len(content_list) == 1:\n        entry[field_key] = content_list[0]\n    return entry\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.journal_booktitle/#pybibtexer.bib.bibtexparser.middlewares.block.journal_booktitle.DeleteRedundantInJournalBooktitle","title":"DeleteRedundantInJournalBooktitle","text":"<pre><code>DeleteRedundantInJournalBooktitle(\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Delete redundant part such as <code>(CEC)</code> in field <code>journal</code> or <code>booktitle</code> value of an entry.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/journal_booktitle.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.month_year/","title":"bib.bibtexparser.middlewares.block.month_year","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.month_year/#pybibtexer.bib.bibtexparser.middlewares.block.month_year-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.month_year/#pybibtexer.bib.bibtexparser.middlewares.block.month_year.ConvertStrMonthToInt","title":"ConvertStrMonthToInt","text":"<pre><code>ConvertStrMonthToInt(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Convert the field <code>month</code> value of an entry when it is str to int type if possible.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/month_year.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.month_year/#pybibtexer.bib.bibtexparser.middlewares.block.month_year.ExtractYear","title":"ExtractYear","text":"<pre><code>ExtractYear(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Convert the field <code>month</code> value of an entry when it is str to int type if possible.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/month_year.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.number_volume/","title":"bib.bibtexparser.middlewares.block.number_volume","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.number_volume/#pybibtexer.bib.bibtexparser.middlewares.block.number_volume-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.number_volume/#pybibtexer.bib.bibtexparser.middlewares.block.number_volume.ConvertStrNumberVolumeToInt","title":"ConvertStrNumberVolumeToInt","text":"<pre><code>ConvertStrNumberVolumeToInt(\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Convert the field <code>number</code> or <code>volume</code> value of an entry when it is str to int type if possible.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/number_volume.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.pages/","title":"bib.bibtexparser.middlewares.block.pages","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.pages/#pybibtexer.bib.bibtexparser.middlewares.block.pages-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.pages/#pybibtexer.bib.bibtexparser.middlewares.block.pages.NormalizePagesInEntry","title":"NormalizePagesInEntry","text":"<pre><code>NormalizePagesInEntry(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Normalize field <code>pages</code> of an entry by deleting redundant part or generating when not existed.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/pages.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.block.title/","title":"bib.bibtexparser.middlewares.block.title","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.title/#pybibtexer.bib.bibtexparser.middlewares.block.title-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.block.title/#pybibtexer.bib.bibtexparser.middlewares.block.title.NormalizeTitleInEntry","title":"NormalizeTitleInEntry","text":"<pre><code>NormalizeTitleInEntry(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>BlockMiddleware</code></p> <p>Normalize field <code>title</code> of an entry by deleting \\href{}{} if existed.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/block/title.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.library.generating_entrykeys/","title":"bib.bibtexparser.middlewares.library.generating_entrykeys","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.library.generating_entrykeys/#pybibtexer.bib.bibtexparser.middlewares.library.generating_entrykeys-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.library.generating_entrykeys/#pybibtexer.bib.bibtexparser.middlewares.library.generating_entrykeys.GenerateEntriesCiteKey","title":"GenerateEntriesCiteKey","text":"<pre><code>GenerateEntriesCiteKey(\n    abbr_article_pattern_dict,\n    abbr_inproceedings_pattern_dict,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>LibraryMiddleware</code></p> <p>Generate entries key of a library.</p> <p>The entry.key is also <code>Cite Key</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/library/generating_entrykeys.py</code> <pre><code>def __init__(\n    self,\n    abbr_article_pattern_dict: dict,\n    abbr_inproceedings_pattern_dict: dict,\n    allow_inplace_modification: bool = True,\n):\n    super().__init__(allow_inplace_modification=allow_inplace_modification)\n\n    self.abbr_article_pattern_dict = abbr_article_pattern_dict\n    self.abbr_inproceedings_pattern_dict = abbr_inproceedings_pattern_dict\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.library.generating_entrykeys/#pybibtexer.bib.bibtexparser.middlewares.library.generating_entrykeys.GenerateEntriesCiteKey-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.library.generating_entrykeys/#pybibtexer.bib.bibtexparser.middlewares.library.generating_entrykeys.GenerateEntriesCiteKey.generate_cite_key","title":"generate_cite_key","text":"<pre><code>generate_cite_key(entry)\n</code></pre> <p>Generate user citation key.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/library/generating_entrykeys.py</code> <pre><code>def generate_cite_key(self, entry: Entry) -&gt; str:\n    \"\"\"Generate user citation key.\"\"\"\n    prefix = generate_cite_key_prefix(\n        entry,\n        self.abbr_article_pattern_dict,\n        self.abbr_inproceedings_pattern_dict,\n    )\n\n    cite_key = self.generate_google_cite_key(entry)\n    if prefix != \"\":\n        cite_key = prefix + \"_\" + cite_key\n    return cite_key\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.library.generating_entrykeys/#pybibtexer.bib.bibtexparser.middlewares.library.generating_entrykeys.GenerateEntriesCiteKey.generate_google_cite_key","title":"generate_google_cite_key","text":"<pre><code>generate_google_cite_key(entry)\n</code></pre> <p>Generate google citation key.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/library/generating_entrykeys.py</code> <pre><code>def generate_google_cite_key(self, entry: Entry) -&gt; str:\n    \"\"\"Generate google citation key.\"\"\"\n    author = entry[\"author\"] if \"author\" in entry else \"\"\n    family_name = self._obtain_family_name(author).lower()\n\n    year = entry[\"year\"] if \"year\" in entry else \"\"\n\n    first_word_of_title = \"\"\n    title = entry[\"title\"] if \"title\" in entry else \"\"\n    regex = re.compile(r\"\\\\href{(.*)}{(.*)}\")\n    if mch := regex.search(title):\n        title = mch.group(2)\n\n    word_list = [w.lower() for w in re.split(r\"\\s+\", title) if w.strip()]\n    word_list = [re.sub(r\"[^a-zA-Z0-9]\", \"\", w) for w in word_list]\n    for w in word_list:\n        if w not in SKIP_WORD_IN_CITATION_KEY:\n            first_word_of_title = w\n            break\n\n    citation_key = family_name + year + first_word_of_title\n    return re.sub(r\"[^a-zA-Z0-9]\", \"\", citation_key)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.library.keeping_blocks/","title":"bib.bibtexparser.middlewares.library.keeping_blocks","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.library.keeping_blocks/#pybibtexer.bib.bibtexparser.middlewares.library.keeping_blocks-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.library.keeping_blocks/#pybibtexer.bib.bibtexparser.middlewares.library.keeping_blocks.KeepEntriesByCiteKey","title":"KeepEntriesByCiteKey","text":"<pre><code>KeepEntriesByCiteKey(\n    entry_keys, allow_inplace_modification=True\n)\n</code></pre> <p>               Bases: <code>LibraryMiddleware</code></p> <p>Keep the entries of a library by <code>Cite Key</code>.</p> <p>The entry.key is also <code>Cite Key</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/library/keeping_blocks.py</code> <pre><code>def __init__(self, entry_keys: list[str], allow_inplace_modification: bool = True):\n    super().__init__(allow_inplace_modification=allow_inplace_modification)\n\n    self.entry_keys = [e.lower() for e in entry_keys]\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.library.protecting_title/","title":"bib.bibtexparser.middlewares.library.protecting_title","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.library.protecting_title/#pybibtexer.bib.bibtexparser.middlewares.library.protecting_title-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.library.sorting_blocks/","title":"bib.bibtexparser.middlewares.library.sorting_blocks","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.library.sorting_blocks/#pybibtexer.bib.bibtexparser.middlewares.library.sorting_blocks-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.library.sorting_blocks/#pybibtexer.bib.bibtexparser.middlewares.library.sorting_blocks.SortBlocksByTypeAndUserSortKeyMiddleware","title":"SortBlocksByTypeAndUserSortKeyMiddleware","text":"<pre><code>SortBlocksByTypeAndUserSortKeyMiddleware(\n    keep_entry_according_cite_keys=None,\n    sort_entry_according_field_keys=None,\n    sort_entry_according_field_keys_reverse=True,\n)\n</code></pre> <p>               Bases: <code>LibraryMiddleware</code></p> <p>Sorts the blocks of a library by type and <code>User Sort Key</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/library/sorting_blocks.py</code> <pre><code>def __init__(\n    self,\n    keep_entry_according_cite_keys: list[str] | None = None,\n    sort_entry_according_field_keys: list[str] | None = None,\n    sort_entry_according_field_keys_reverse: bool = True,\n):\n    if keep_entry_according_cite_keys is None:\n        keep_entry_according_cite_keys = []\n    if sort_entry_according_field_keys is None:\n        sort_entry_according_field_keys = [\"year\", \"volume\", \"number\", \"month\", \"pages\"]\n\n    self._verify_all_types_are_block_types(DEFAULT_BLOCK_TYPE_ORDER)\n    self.keep_entry_according_cite_keys = keep_entry_according_cite_keys\n    self.sort_entry_according_field_keys = sort_entry_according_field_keys\n    self.sort_entry_according_field_keys_reverse = sort_entry_according_field_keys_reverse\n\n    # In-place modification is not yet supported, we make this explicit here,\n    super().__init__(allow_inplace_modification=False)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/","title":"bib.bibtexparser.middlewares.middleware","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.BlockMiddleware","title":"BlockMiddleware","text":"<pre><code>BlockMiddleware(\n    allow_parallel_execution=True,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>Middleware</code>, <code>ABC</code></p> <p>Transform a library on a per-block basis.</p> <p>The <code>BlockMiddleware</code> replaces a block with zero, one or more new (transformed) blocks.</p> <p>Changes may rely on the state of the overall library, but must not change the state of the library directly, except if <code>allow_inplace_modification</code> is true.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>def __init__(self, allow_parallel_execution: bool = True, allow_inplace_modification: bool = True):\n    \"\"\"Create a new Middleware.\n\n    :param allow_inplace_modification: See corresponding property.\n    :param allow_parallel_execution: See corresponding property.\n    \"\"\"\n    self._allow_inplace_modification = allow_inplace_modification\n    self._allow_parallel_execution = allow_parallel_execution\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.BlockMiddleware-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.BlockMiddleware.metadata_key","title":"metadata_key  <code>classmethod</code>","text":"<pre><code>metadata_key()\n</code></pre> <p>Tt is the identifier of the middleware.</p> <p>This key is used to identify the middleware in a blocks metadata.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>@classmethod\ndef metadata_key(cls) -&gt; str:\n    \"\"\"Tt is the identifier of the middleware.\n\n    This key is used to identify the middleware in a blocks metadata.\n    \"\"\"\n    return cls.__name__\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.BlockMiddleware.transform_block","title":"transform_block","text":"<pre><code>transform_block(block, library)\n</code></pre> <p>Transform a block.</p> <p>:param block: Block to transform. :param library: Library containing the block.     Should typically not be modified during     the transformation, but be considered as read-only.     If the library is modified, make sure to set the <code>allow_multithreading</code>     constructor argument to false :return: Transformed block. If the block should be removed, return None.     If the block should be replaced by multiple blocks, return a collection     of blocks. If the block should be replaced by a single block, return     the single block. If the block should not be modified, return a copy of     the original block.     The returned block has to be a new instance, except if     <code>self.allow_inplace_modification</code> is True (in which case the block     may also return the original block).</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>def transform_block(self, block: Block, library: Library) -&gt; Block | Collection[Block] | None:\n    \"\"\"Transform a block.\n\n    :param block: Block to transform.\n    :param library: Library containing the block.\n        Should typically not be modified during\n        the transformation, but be considered as read-only.\n        If the library is modified, make sure to set the `allow_multithreading`\n        constructor argument to false\n    :return: Transformed block. If the block should be removed, return None.\n        If the block should be replaced by multiple blocks, return a collection\n        of blocks. If the block should be replaced by a single block, return\n        the single block. If the block should not be modified, return a copy of\n        the original block.\n        The returned block has to be a new instance, except if\n        `self.allow_inplace_modification` is True (in which case the block\n        may also return the original block).\n    \"\"\"\n    block = block if self.allow_inplace_modification else deepcopy(block)\n    if isinstance(block, Entry):\n        return self.transform_entry(block, library)\n    elif isinstance(block, String):\n        return self.transform_string(block, library)\n    elif isinstance(block, Preamble):\n        return self.transform_preamble(block, library)\n    elif isinstance(block, ExplicitComment):\n        return self.transform_explicit_comment(block, library)\n    elif isinstance(block, ImplicitComment):\n        return self.transform_implicit_comment(block, library)\n\n    # logger.warning(f\"Unknown block type {type(block)}\")\n    return block\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.BlockMiddleware.transform_entry","title":"transform_entry","text":"<pre><code>transform_entry(entry, library)\n</code></pre> <p>Transform an entry. Called by <code>transform_block</code> if the block is an entry.</p> <p>Note: This method modifies the passed entry. For a method respecting the <code>allow_inplace_modification</code> property, you should use <code>transform</code> or <code>transform_block</code> instead.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>def transform_entry(self, entry: Entry, library: Library) -&gt; Block | Collection[Block] | None:\n    \"\"\"Transform an entry. Called by `transform_block` if the block is an entry.\n\n    Note: This method modifies the passed entry. For a method\n    respecting the `allow_inplace_modification` property,\n    you should use `transform` or `transform_block` instead.\n    \"\"\"\n    return entry\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.BlockMiddleware.transform_explicit_comment","title":"transform_explicit_comment","text":"<pre><code>transform_explicit_comment(explicit_comment, library)\n</code></pre> <p>Transform an explicit comment. Called by <code>transform_block</code> if the block is an explicit comment.</p> <p>Note: This method modifies the passed explicit comment. For a method respecting the <code>allow_inplace_modification</code> property, you should use <code>transform</code> or <code>transform_block</code> instead.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>def transform_explicit_comment(\n    self, explicit_comment: ExplicitComment, library: Library\n) -&gt; Block | Collection[Block] | None:\n    \"\"\"Transform an explicit comment. Called by `transform_block` if the block is an explicit comment.\n\n    Note: This method modifies the passed explicit comment. For a method\n    respecting the `allow_inplace_modification` property,\n    you should use `transform` or `transform_block` instead.\n    \"\"\"\n    return explicit_comment\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.BlockMiddleware.transform_implicit_comment","title":"transform_implicit_comment","text":"<pre><code>transform_implicit_comment(implicit_comment, library)\n</code></pre> <p>Transform an implicit comment. Called by <code>transform_block</code> if the block is an implicit comment.</p> <p>Note: This method modifies the passed implicit comment. For a method respecting the <code>allow_inplace_modification</code> property, you should use <code>transform</code> or <code>transform_block</code> instead.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>def transform_implicit_comment(\n    self, implicit_comment: ImplicitComment, library: Library\n) -&gt; Block | Collection[Block] | None:\n    \"\"\"Transform an implicit comment. Called by `transform_block` if the block is an implicit comment.\n\n    Note: This method modifies the passed implicit comment. For a method\n    respecting the `allow_inplace_modification` property,\n    you should use `transform` or `transform_block` instead.\n    \"\"\"\n    return implicit_comment\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.BlockMiddleware.transform_preamble","title":"transform_preamble","text":"<pre><code>transform_preamble(preamble, library)\n</code></pre> <p>Transform a preamble. Called by <code>transform_block</code> if the block is a preamble.</p> <p>Note: This method modifies the passed preamble. For a method respecting the <code>allow_inplace_modification</code> property, you should use <code>transform</code> or <code>transform_block</code> instead.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>def transform_preamble(self, preamble: Preamble, library: Library) -&gt; Block | Collection[Block] | None:\n    \"\"\"Transform a preamble. Called by `transform_block` if the block is a preamble.\n\n    Note: This method modifies the passed preamble. For a method\n    respecting the `allow_inplace_modification` property,\n    you should use `transform` or `transform_block` instead.\n    \"\"\"\n    return preamble\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.BlockMiddleware.transform_string","title":"transform_string","text":"<pre><code>transform_string(string, library)\n</code></pre> <p>Transform a string. Called by <code>transform_block</code> if the block is a string.</p> <p>Note: This method modifies the passed string. For a method respecting the <code>allow_inplace_modification</code> property, you should use <code>transform</code> or <code>transform_block</code> instead.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>def transform_string(self, string: String, library: Library) -&gt; Block | Collection[Block] | None:\n    \"\"\"Transform a string. Called by `transform_block` if the block is a string.\n\n    Note: This method modifies the passed string. For a method\n    respecting the `allow_inplace_modification` property,\n    you should use `transform` or `transform_block` instead.\n    \"\"\"\n    return string\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.LibraryMiddleware","title":"LibraryMiddleware","text":"<pre><code>LibraryMiddleware(allow_inplace_modification=True)\n</code></pre> <p>               Bases: <code>Middleware</code>, <code>ABC</code></p> <p>Changes an overall library at once (not just on a per-block basis).</p> <p>Examples of library-wide changes are: - Re-Sorting the blocks in the library. - Transforming the library instance to a custom subclass of Library.</p> <p>Whatever can be done in a BlockMiddleware, should be done in a BlockMiddleware (and not in a LibraryMiddleware), for performance reasons (e.g. deleting blocks, ...).</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>def __init__(self, allow_inplace_modification: bool = True):\n    # As library middleware is run per library (not per block individually),\n    #   it cannot be parallelized.\n    super().__init__(allow_inplace_modification=allow_inplace_modification, allow_parallel_execution=False)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.LibraryMiddleware-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.LibraryMiddleware.transform","title":"transform","text":"<pre><code>transform(library)\n</code></pre> <p>Transform a library.</p> <p>:param library: Library to transform. :return: Transformed library. If the library should not be modified,     return a copy of the original library.     The returned library has to be a new instance, except if     <code>self.allow_inplace_modification</code> is True (in which case the library     may also return the original library).</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>def transform(self, library: Library) -&gt; Library:\n    \"\"\"Transform a library.\n\n    :param library: Library to transform.\n    :return: Transformed library. If the library should not be modified,\n        return a copy of the original library.\n        The returned library has to be a new instance, except if\n        `self.allow_inplace_modification` is True (in which case the library\n        may also return the original library).\n    \"\"\"\n    library = library if self.allow_inplace_modification else deepcopy(library)\n    return library\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.Middleware","title":"Middleware","text":"<pre><code>Middleware(\n    allow_parallel_execution=True,\n    allow_inplace_modification=True,\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Implements a function to transform a block or library.</p> <p>Abstract Class. You should extend either BlockMiddleware or LibraryMiddleware</p> <p>Create a new Middleware.</p> <p>:param allow_inplace_modification: See corresponding property. :param allow_parallel_execution: See corresponding property.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>def __init__(self, allow_parallel_execution: bool = True, allow_inplace_modification: bool = True):\n    \"\"\"Create a new Middleware.\n\n    :param allow_inplace_modification: See corresponding property.\n    :param allow_parallel_execution: See corresponding property.\n    \"\"\"\n    self._allow_inplace_modification = allow_inplace_modification\n    self._allow_parallel_execution = allow_parallel_execution\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.Middleware-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.Middleware.allow_inplace_modification","title":"allow_inplace_modification  <code>property</code>","text":"<pre><code>allow_inplace_modification\n</code></pre> <p>If true, the middleware may modify the block in-place.</p> <p>I.e., if true, the output of <code>transform</code> may be the same instance as the input. If false, new instances must be returned.</p>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.Middleware.allow_parallel_execution","title":"allow_parallel_execution  <code>property</code>","text":"<pre><code>allow_parallel_execution\n</code></pre> <p>True indicates that the middleware is threadsafe.</p>"},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.Middleware-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.middleware/#pybibtexer.bib.bibtexparser.middlewares.middleware.Middleware.transform","title":"transform  <code>abstractmethod</code>","text":"<pre><code>transform(library)\n</code></pre> <p>Apply transformation to a library. Main entrypoint of the middleware.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/middleware.py</code> <pre><code>@abc.abstractmethod\ndef transform(self, library: Library) -&gt; Library:\n    \"\"\"Apply transformation to a library. Main entrypoint of the middleware.\"\"\"\n    raise NotImplementedError(\"called abstract method\")\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.parsestack/","title":"bib.bibtexparser.middlewares.parsestack","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.parsestack/#pybibtexer.bib.bibtexparser.middlewares.parsestack-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.parsestack/#pybibtexer.bib.bibtexparser.middlewares.parsestack-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.parsestack/#pybibtexer.bib.bibtexparser.middlewares.parsestack.default_parse_stack","title":"default_parse_stack","text":"<pre><code>default_parse_stack(allow_inplace_modification=True)\n</code></pre> <p>Give the default parse stack to be applied after splitting, if not specified otherwise.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/parsestack.py</code> <pre><code>def default_parse_stack(allow_inplace_modification: bool = True) -&gt; list[Middleware]:\n    \"\"\"Give the default parse stack to be applied after splitting, if not specified otherwise.\"\"\"\n    return []\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.parsestack/#pybibtexer.bib.bibtexparser.middlewares.parsestack.default_unparse_stack","title":"default_unparse_stack","text":"<pre><code>default_unparse_stack(allow_inplace_modification=False)\n</code></pre> <p>Give the default unparse stack to be applied before writing, if not specified otherwise.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/parsestack.py</code> <pre><code>def default_unparse_stack(allow_inplace_modification: bool = False) -&gt; list[Middleware]:\n    \"\"\"Give the default unparse stack to be applied before writing, if not specified otherwise.\"\"\"\n    return []\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares.utils/","title":"bib.bibtexparser.middlewares.utils","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.utils/#pybibtexer.bib.bibtexparser.middlewares.utils-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.utils/#pybibtexer.bib.bibtexparser.middlewares.utils-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.middlewares.utils/#pybibtexer.bib.bibtexparser.middlewares.utils.generate_entry_abbr","title":"generate_entry_abbr","text":"<pre><code>generate_entry_abbr(entry_type)\n</code></pre> <p>Generate abbr according to entry type.</p> zotero item type <p>['Journal Article', 'Conference Paper', 'Book', 'Book Section', 'Document', 'Manuscript', 'Report', 'Thesis',  'Thesis']</p> <p>zotero export:     ['article', 'inproceedings','book', 'incollection', 'misc', 'unpublished', 'techreport', 'phdthesis',      'masterthesis']</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares/utils.py</code> <pre><code>def generate_entry_abbr(entry_type: str) -&gt; str:\n    \"\"\"Generate abbr according to entry type.\n\n    zotero item type:\n        ['Journal Article', 'Conference Paper', 'Book', 'Book Section', 'Document', 'Manuscript', 'Report', 'Thesis',\n         'Thesis']\n    zotero export:\n        ['article', 'inproceedings','book', 'incollection', 'misc', 'unpublished', 'techreport', 'phdthesis',\n         'masterthesis']\n    \"\"\"\n    entries = {k[0]: k[2] for k in MARKS_FLAGS if k[1] == \"entry\"}\n    return entries.get(entry_type.lower(), \"\")\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares_library_to_library/","title":"bib.bibtexparser.middlewares_library_to_library","text":""},{"location":"api-auto/bib.bibtexparser.middlewares_library_to_library/#pybibtexer.bib.bibtexparser.middlewares_library_to_library-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares_library_to_library/#pybibtexer.bib.bibtexparser.middlewares_library_to_library.MiddlewaresLibraryToLibrary","title":"MiddlewaresLibraryToLibrary","text":"<pre><code>MiddlewaresLibraryToLibrary(options)\n</code></pre> <p>Middlewares for converting a library to a library.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict</code> <p>Options for the middlewares.</p> required <p>Attributes:</p> Name Type Description <code>function_common_again</code> <code>bool</code> <p>Run common middlewares again. Default is True.</p> <code>lower_entry_type</code> <code>bool</code> <p>Lower Entry type. Default is True.</p> <code>lower_entry_field_key</code> <code>bool</code> <p>Lower Entry field keys. Default is True.</p> <code>keep_entries_by_cite_keys</code> <code>list</code> <p>list of keys to keep entries in the order of cite keys. Default is [].</p> <code>update_month</code> <code>bool</code> <p>Convert str month to int month. Default is True.</p> <code>update_number_volume</code> <code>bool</code> <p>Update number and volume. Default is True.</p> <code>update_pages</code> <code>bool</code> <p>Update pages. Default is True.</p> <code>update_title</code> <code>bool</code> <p>Update title. Default is True.</p> <code>sentence_title_case</code> <code>bool</code> <p>Sentence title case. Default is True.</p> <code>generate_entry_cite_keys</code> <code>bool</code> <p>Generate Entry keys (cite keys). Default is False.</p> <code>full_abbr_article_dict</code> <code>dict</code> <p>Full to abbreviation dictionary for article. Default is {}.</p> <code>full_abbr_inproceedings_dict</code> <code>dict</code> <p>Full to abbreviation dictionary for inproceedings. Default is {}.</p> <code>full_names_in_json</code> <code>str</code> <p>Full names in json format. Default is \"\".</p> <code>abbr_names_in_json</code> <code>str</code> <p>Abbreviated names in json format. Default is \"\".</p> <code>abbr_article_pattern_dict</code> <code>dict</code> <p>Pre-compiled regex patterns for journal name matching</p> <code>abbr_inproceedings_pattern_dict</code> <code>dict</code> <p>Pre-compiled regex patterns for conference name matching</p> <code>full_to_abbr_for_abbr</code> <code>bool</code> <p>Full to abbreviation for abbreviate. Default is True.</p> <code>abbr_index_article_for_abbr</code> <code>int</code> <p>Index for abbreviation in article. Default is 1.</p> <code>abbr_index_inproceedings_for_abbr</code> <code>int</code> <p>Index for abbreviation in inproceedings. Default is 2.</p> <code>protect_title_with_bracket_for_abbr</code> <code>bool</code> <p>Protect title with bracket. Default is True</p> <code>doi_or_url_for_abbr</code> <code>bool</code> <p>Keep only doi or url. Default is True.</p> <code>doi_to_url_for_abbr</code> <code>bool</code> <p>Change doi to url and delete original doi. Default is True.</p> <code>add_link_to_fields_for_abbr</code> <code>Optional[list[str]] = None</code> <p>Add link to fields. Default is None.</p> <code>is_keep_fields_for_abbr</code> <code>bool</code> <p>Keep fields for abbreviate. Default is True.</p> <code>keep_entry_list_for_abbr</code> <code>list</code> <p>Entry list for keep fields. Default is keep_for_abbr()[0].</p> <code>keep_field_list_list_for_abbr</code> <code>list</code> <p>Field list list for keep fields. Default is keep_for_abbr()[1].</p> <code>delete_field_list_for_abbr</code> <code>list</code> <p>Delete fields list for abbreviate. Default is [].</p> <code>replace_fields_for_abbr</code> <code>bool</code> <p>Replace fields for abbreviate. Default is True.</p> <code>replace_old_field_list_for_abbr</code> <code>list</code> <p>Old field list for replace. Default is [[\"publisher\"]].</p> <code>replace_new_field_list_for_abbr</code> <code>list</code> <p>New field list for replace. Default is [[\"howpublished\"]].</p> <code>replace_entry_list_for_abbr</code> <code>list</code> <p>Entry list for replace. Default is [\"misc\"].</p> <code>maximum_authors_for_abbr</code> <code>int</code> <p>Maximum number of authors. Default is 0.</p> <code>protect_title_with_bracket_for_zotero</code> <code>bool</code> <p>Protect title with bracket. Default is False</p> <code>doi_or_url_for_zotero</code> <code>bool</code> <p>Keep only doi or url. Default is True.</p> <code>is_keep_fields_for_zotero</code> <code>bool</code> <p>Keep fields for zotero. Default is True.</p> <code>keep_entry_list_for_zotero</code> <code>list</code> <p>Entry list for keep fields. Default is keep_for_zotero()[0].</p> <code>keep_field_list_list_for_zotero</code> <code>list</code> <p>Field list list for keep fields. Default is keep_for_zotero()[1].</p> <code>delete_field_list_for_zotero</code> <code>list</code> <p>Delete fields list for zotero. Default is [].</p> <code>delete_redundant_in_journal_booktitle</code> <code>bool</code> <p>Delete redundant parts in journal and booktitle. Default is True.</p> <code>title_journal_booktitle_for_zotero</code> <code>bool</code> <p>Title journal and booktitle contents. Default is True.</p> <code>add_archive_for_zotero</code> <code>bool</code> <p>Add field 'archive'. Default is True.</p> <code>add_journal_abbr_for_zotero</code> <code>bool</code> <p>Add 'journal/booktitle abbreviation'. Default is True.</p> <code>protect_title_with_bracket_for_save</code> <code>bool</code> <p>Protect title with bracket. Default is False</p> <code>delete_field_list_for_save</code> <code>list</code> <p>Delete fields list for save. Default is [].</p> <code>is_sort_entry_fields</code> <code>bool</code> <p>Sort entry fields alphabetically. Default is True.</p> <code>is_sort_blocks</code> <code>bool</code> <p>Sort entries by type and user sort key. Default is True.</p> <code>sort_entries_by_cite_keys</code> <code>list</code> <p>list of keys to sort entries in the order of cite keys. Default is [].</p> <code>sort_entries_by_field_keys</code> <code>list</code> <p>list of keys to sort entries in the order of field keys. Default is [\"year\", \"volume\", \"number\", \"month\", \"pages\"].</p> <code>sort_entries_by_field_keys_reverse</code> <code>bool</code> <p>Reverse the sorting of the field keys. Default is True.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares_library_to_library.py</code> <pre><code>def __init__(self, options: dict[str, Any]):\n    self.function_common_again = options.get(\"function_common_again\", True)\n    self.function_common_again_for_abbr = options.get(\"function_common_again_for_abbr\", True)\n    self.function_common_again_for_zotero = options.get(\"function_common_again_for_zotero\", True)\n    self.function_common_again_for_save = options.get(\"function_common_again_for_save\", True)\n    self._initialize_function_sort(options)\n\n    self._initialize_function_common(options)\n    self._initialize_function_abbr(options)\n    self._initialize_function_zotero(options)\n    self._initialize_function_save(options)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares_library_to_str/","title":"bib.bibtexparser.middlewares_library_to_str","text":""},{"location":"api-auto/bib.bibtexparser.middlewares_library_to_str/#pybibtexer.bib.bibtexparser.middlewares_library_to_str-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares_library_to_str/#pybibtexer.bib.bibtexparser.middlewares_library_to_str.MiddlewaresLibraryToStr","title":"MiddlewaresLibraryToStr","text":"<pre><code>MiddlewaresLibraryToStr(options)\n</code></pre> <p>Middlewares for converting a library to a string.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict</code> <p>Options for the middlewares.</p> required <p>Attributes:</p> Name Type Description <code>is_sort_entry_fields</code> <code>bool</code> <p>Sort entry fields alphabetically. Default is True.</p> <code>is_sort_blocks</code> <code>bool</code> <p>Sort entries by type and user sort key. Default is True.</p> <code>sort_entries_by_cite_keys</code> <code>list</code> <p>list of keys to sort entries in the order of cite keys. Default is [].</p> <code>sort_entries_by_field_keys</code> <code>list</code> <p>list of keys to sort entries in the order of field keys. Default is [\"year\", \"volume\", \"number\", \"month\", \"pages\"].</p> <code>sort_entries_by_field_keys_reverse</code> <code>bool</code> <p>Reverse the sorting of the field keys. Default is True.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares_library_to_str.py</code> <pre><code>def __init__(self, options: dict[str, Any]):\n    self.is_sort_entry_fields = options.get(\"is_sort_entry_fields\", True)\n    self.is_sort_blocks = options.get(\"is_sort_blocks\", True)\n    self.sort_entries_by_cite_keys = options.get(\"sort_entries_by_cite_keys\", [])\n    self.sort_entries_by_field_keys = options.get(\n        \"sort_entries_by_field_keys\", [\"year\", \"volume\", \"number\", \"month\", \"pages\"]\n    )\n    self.sort_entries_by_field_keys_reverse = options.get(\"sort_entries_by_field_keys_reverse\", True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares_str_to_library/","title":"bib.bibtexparser.middlewares_str_to_library","text":""},{"location":"api-auto/bib.bibtexparser.middlewares_str_to_library/#pybibtexer.bib.bibtexparser.middlewares_str_to_library-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares_str_to_library/#pybibtexer.bib.bibtexparser.middlewares_str_to_library.MiddlewaresStrToLibrary","title":"MiddlewaresStrToLibrary","text":"<pre><code>MiddlewaresStrToLibrary(options)\n</code></pre> <p>Middlewares for converting a string to a library.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict</code> <p>Options for the middlewares.</p> required <p>Attributes:</p> Name Type Description <code>is_display_implicit_comments</code> <code>bool</code> <p>Display implicit comments. Default is True.</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares_str_to_library.py</code> <pre><code>def __init__(self, options: dict[str, Any]):\n    self.is_display_implicit_comments = options.get(\"is_display_implicit_comments\", True)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.middlewares_str_to_str/","title":"bib.bibtexparser.middlewares_str_to_str","text":""},{"location":"api-auto/bib.bibtexparser.middlewares_str_to_str/#pybibtexer.bib.bibtexparser.middlewares_str_to_str-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.middlewares_str_to_str/#pybibtexer.bib.bibtexparser.middlewares_str_to_str.MiddlewaresStrToStr","title":"MiddlewaresStrToStr","text":"<pre><code>MiddlewaresStrToStr(options)\n</code></pre> <p>Middlewares for converting a string to a string.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict</code> <p>Options for the middlewares.</p> required <p>Attributes:</p> Name Type Description <code>substitute_in_bib</code> <code>bool</code> <p>Substitute in the bib. Default is True.</p> <code>substitute_old_list</code> <code>list</code> <p>list of old strings to substitute. Default is [].</p> <code>substitute_new_list</code> <code>list</code> <p>list of new strings to substitute. Default is [].</p> Source code in <code>pybibtexer/bib/bibtexparser/middlewares_str_to_str.py</code> <pre><code>def __init__(self, options: dict[str, Any]):\n    self.substitute_in_bib = options.get(\"substitute_in_bib\", True)\n    self.substitute_old_list = options.get(\"substitute_old_list\", [])\n    self.substitute_new_list = options.get(\"substitute_new_list\", [])\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/","title":"bib.bibtexparser.model","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Block","title":"Block","text":"<pre><code>Block(start_line=None, raw=None, parser_metadata=None)\n</code></pre> <p>A abstract superclass of all top-level building blocks of a bibtex file.</p> <p>E.g. a <code>@string</code> block, a <code>@preamble</code> block, an <code>@entry</code> block, a comment, etc.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(\n    self,\n    start_line: int | None = None,\n    raw: str | None = None,\n    parser_metadata: dict[str, Any] | None = None,\n):\n    self._start_line = start_line\n    self._raw = raw\n    self._parser_metadata: dict[str, Any] = {}\n    if parser_metadata is not None:\n        self._parser_metadata: dict[str, Any] = parser_metadata\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Block-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Block.parser_metadata","title":"parser_metadata  <code>property</code>","text":"<pre><code>parser_metadata\n</code></pre> <p>EXPERIMENTAL: field for middleware to store auxiliary information.</p> <p>As an end-user, as long as you are not writing middleware, you probably do not need to use this field.</p> <p>** Warning (experimental) ** The content of this field is undefined and may change at any time.</p> <p>This field is intended for middleware to store auxiliary information. It is a key-value store, where the key is a string and the value is any python object. This allows for example to pass information between different middleware.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Block.raw","title":"raw  <code>property</code>","text":"<pre><code>raw\n</code></pre> <p>The raw, unmodified string (bibtex) representation of this block.</p> <p>Note: Middleware does not update this field, hence, after applying middleware to a library, this field may be outdated.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Block.start_line","title":"start_line  <code>property</code>","text":"<pre><code>start_line\n</code></pre> <p>The line number of the first line of this block in the parsed string.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Block-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Block.get_parser_metadata","title":"get_parser_metadata","text":"<pre><code>get_parser_metadata(key)\n</code></pre> <p>EXPERIMENTAL: get auxiliary information stored in <code>parser_metadata</code>.</p> <p>See attribute <code>parser_metadata</code> for more information.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def get_parser_metadata(self, key: str) -&gt; Any | None:\n    \"\"\"EXPERIMENTAL: get auxiliary information stored in ``parser_metadata``.\n\n    See attribute ``parser_metadata`` for more information.\n    \"\"\"\n    return self._parser_metadata.get(key, None)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Block.set_parser_metadata","title":"set_parser_metadata","text":"<pre><code>set_parser_metadata(key, value)\n</code></pre> <p>EXPERIMENTAL: set auxiliary information stored in <code>parser_metadata</code>.</p> <p>See attribute <code>parser_metadata</code> for more information.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def set_parser_metadata(self, key: str, value: Any):\n    \"\"\"EXPERIMENTAL: set auxiliary information stored in ``parser_metadata``.\n\n    See attribute ``parser_metadata`` for more information.\n    \"\"\"\n    self._parser_metadata[key] = value\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.DuplicateBlockKeyBlock","title":"DuplicateBlockKeyBlock","text":"<pre><code>DuplicateBlockKeyBlock(\n    key,\n    previous_block,\n    duplicate_block,\n    start_line=None,\n    raw=None,\n)\n</code></pre> <p>               Bases: <code>ParsingFailedBlock</code></p> <p>An error-indicating block created for blocks with keys present in the library already.</p> <p>To get the block that caused this error, call <code>block.ignore_error_block</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(\n    self,\n    key: str,\n    previous_block: Block,\n    duplicate_block: Block,\n    start_line: int | None = None,\n    raw: str | None = None,\n):\n    super().__init__(\n        error=Exception(f\"Duplicate entry key '{key}'\"),\n        start_line=start_line,\n        raw=raw,\n        ignore_error_block=duplicate_block,\n    )\n    self._key = key\n    self._previous_block = previous_block\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.DuplicateBlockKeyBlock-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.DuplicateBlockKeyBlock.key","title":"key  <code>property</code> <code>writable</code>","text":"<pre><code>key\n</code></pre> <p>The key of the entry, e.g. <code>Cesar2013</code> in <code>@article{Cesar2013, ...}</code>.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.DuplicateBlockKeyBlock.previous_block","title":"previous_block  <code>property</code>","text":"<pre><code>previous_block\n</code></pre> <p>A reference to a previous block with the same key.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.DuplicateFieldKeyBlock","title":"DuplicateFieldKeyBlock","text":"<pre><code>DuplicateFieldKeyBlock(duplicate_keys, entry)\n</code></pre> <p>               Bases: <code>ParsingFailedBlock</code></p> <p>An error-indicating block indicating a duplicate field key in an entry.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(self, duplicate_keys: set[str], entry: Entry):\n    sorted_duplicate_keys = sorted(duplicate_keys)\n    super().__init__(\n        error=Exception(\n            f\"Duplicate field keys on entry: '{', '.join(sorted_duplicate_keys)}'.\"\n            f\"Note: The entry (containing duplicate) is available as `failed_block.entry`\"\n        ),\n        start_line=entry.start_line,\n        raw=entry.raw,\n        ignore_error_block=entry,\n    )\n    self._duplicate_keys: set[str] = duplicate_keys\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.DuplicateFieldKeyBlock-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.DuplicateFieldKeyBlock.duplicate_keys","title":"duplicate_keys  <code>property</code>","text":"<pre><code>duplicate_keys\n</code></pre> <p>The field-keys that occurred more than once in the entry.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry","title":"Entry","text":"<pre><code>Entry(entry_type, key, fields, start_line=None, raw=None)\n</code></pre> <p>               Bases: <code>Block</code></p> <p>Bibtex Blocks of the <code>@entry</code> type, e.g. <code>@article{Cesar2013, ...}</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(\n    self,\n    entry_type: str,\n    key: str,\n    fields: list[Field],\n    start_line: int | None = None,\n    raw: str | None = None,\n):\n    super().__init__(start_line, raw)\n    self._entry_type = entry_type\n    self._key = key\n    self._fields = fields\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.entry_type","title":"entry_type  <code>property</code> <code>writable</code>","text":"<pre><code>entry_type\n</code></pre> <p>The type of the entry, e.g. <code>article</code> in <code>@article{Cesar2013, ...}</code>.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.fields","title":"fields  <code>property</code> <code>writable</code>","text":"<pre><code>fields\n</code></pre> <p>The key-value attributes of an entry, as <code>Field</code> instances.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.fields_dict","title":"fields_dict  <code>property</code>","text":"<pre><code>fields_dict\n</code></pre> <p>A dict of fields, with field keys as keys.</p> <p>Note that with duplicate field keys, the behavior is undefined.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.key","title":"key  <code>property</code> <code>writable</code>","text":"<pre><code>key\n</code></pre> <p>The key of the entry, e.g. <code>Cesar2013</code> in <code>@article{Cesar2013, ...}</code>.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.__contains__","title":"__contains__","text":"<pre><code>__contains__(key)\n</code></pre> <p>Dict-mimicking <code>in</code> operator.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    \"\"\"Dict-mimicking ``in`` operator.\"\"\"\n    return key in self.fields_dict\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key)\n</code></pre> <p>Dict-mimicking index.</p> <p>This serves for partial v1.x backwards compatibility, as well as for a shorthand for <code>pop</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __delitem__(self, key):\n    \"\"\"Dict-mimicking index.\n\n    This serves for partial v1.x backwards compatibility,\n    as well as for a shorthand for `pop`.\n    \"\"\"\n    self.pop(key)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Dict-mimicking index.</p> <p>This serves for partial v1.x backwards compatibility, as well as for a shorthand for accessing field values.</p> <p>Note that with duplicate field keys, the behavior is undefined.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Dict-mimicking index.\n\n    This serves for partial v1.x backwards compatibility,\n    as well as for a shorthand for accessing field values.\n\n    Note that with duplicate field keys, the behavior is undefined.\n    \"\"\"\n    if key == \"ENTRYTYPE\":\n        return self.entry_type\n    if key == \"ID\":\n        return self.key\n    return self.fields_dict[key].value\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Dict-mimicking index.</p> <p>This serves for partial v1.x backwards compatibility, as well as for a shorthand for <code>set_field</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __setitem__(self, key: str, value: Any):\n    \"\"\"Dict-mimicking index.\n\n    This serves for partial v1.x backwards compatibility,\n    as well as for a shorthand for `set_field`.\n    \"\"\"\n    self.set_field(Field(key, value))\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.get","title":"get","text":"<pre><code>get(key, default=None)\n</code></pre> <p>Return the field with the given key, or the default value if it does not exist.</p> <p>:param key: The key of the field. :param default: The value to return if the field does not exist.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def get(self, key: str, default=None) -&gt; Field | None:\n    \"\"\"Return the field with the given key, or the default value if it does not exist.\n\n    :param key: The key of the field.\n    :param default: The value to return if the field does not exist.\n    \"\"\"\n    return self.fields_dict.get(key, default)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Dict-mimicking, for partial v1.x backwards compatibility.</p> <p>For newly written code, it's recommended to use <code>entry.entry_type</code>, <code>entry.key</code> and <code>entry.fields</code> instead.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def items(self):\n    \"\"\"Dict-mimicking, for partial v1.x backwards compatibility.\n\n    For newly written code, it's recommended to use `entry.entry_type`,\n    `entry.key` and `entry.fields` instead.\n    \"\"\"\n    return [(\"ENTRYTYPE\", self.entry_type), (\"ID\", self.key)] + [(f.key, f.value) for f in self.fields]\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.pop","title":"pop","text":"<pre><code>pop(key, default=None)\n</code></pre> <p>Remove and return the field with the given key.</p> <p>:param key: The key of the field to remove. :param default: The value to return if the field does not exist.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def pop(self, key: str, default=None) -&gt; Field | None:\n    \"\"\"Remove and return the field with the given key.\n\n    :param key: The key of the field to remove.\n    :param default: The value to return if the field does not exist.\n    \"\"\"\n    try:\n        field = self.fields_dict.pop(key)\n    except KeyError:\n        return default\n\n    self._fields = [f for f in self._fields if f.key != key]\n    return field\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Entry.set_field","title":"set_field","text":"<pre><code>set_field(field)\n</code></pre> <p>Add a new field, or replaces existing with same key.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def set_field(self, field: Field):\n    \"\"\"Add a new field, or replaces existing with same key.\"\"\"\n    if field.key in self.fields_dict:\n        i = [f.key for f in self._fields].index(field.key)\n        self._fields[i] = field\n    else:\n        self._fields.append(field)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.ExplicitComment","title":"ExplicitComment","text":"<pre><code>ExplicitComment(comment, start_line=None, raw=None)\n</code></pre> <p>               Bases: <code>Block</code></p> <p>Bibtex Blocks of the <code>@comment</code> type, e.g. <code>@comment{This is a comment}</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(self, comment: str, start_line: int | None = None, raw: str | None = None):\n    super().__init__(start_line, raw)\n    self._comment = comment\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.ExplicitComment-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.ExplicitComment.comment","title":"comment  <code>property</code> <code>writable</code>","text":"<pre><code>comment\n</code></pre> <p>The value of the comment, e.g. <code>blabla</code> in <code>@comment{blabla}</code>.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Field","title":"Field","text":"<pre><code>Field(key, value, start_line=None)\n</code></pre> <p>A field of a Bibtex entry, e.g. <code>author = {John Doe}</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(self, key: str, value: Any, start_line: int | None = None):\n    self._start_line = start_line\n    self._key = key\n    self._value = value\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Field-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Field.key","title":"key  <code>property</code> <code>writable</code>","text":"<pre><code>key\n</code></pre> <p>The key of the field, e.g. <code>author</code> in <code>author = {John Doe}</code>.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Field.start_line","title":"start_line  <code>property</code>","text":"<pre><code>start_line\n</code></pre> <p>The line number of the first line of this field in the originally parsed string.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Field.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre> <p>The value of the field, e.g. <code>{John Doe}</code> in <code>author = {John Doe}</code>.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.ImplicitComment","title":"ImplicitComment","text":"<pre><code>ImplicitComment(comment, start_line=None, raw=None)\n</code></pre> <p>               Bases: <code>Block</code></p> <p>Bibtex outside of an <code>@{...}</code> block, which is treated as a comment.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(self, comment: str, start_line: int | None = None, raw: str | None = None):\n    super().__init__(start_line, raw)\n    self._comment = comment\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.ImplicitComment-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.ImplicitComment.comment","title":"comment  <code>property</code> <code>writable</code>","text":"<pre><code>comment\n</code></pre> <p>The (possibly multi-line) comment.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.MiddlewareErrorBlock","title":"MiddlewareErrorBlock","text":"<pre><code>MiddlewareErrorBlock(block, error)\n</code></pre> <p>               Bases: <code>ParsingFailedBlock</code></p> <p>A block that could not be parsed due to a middleware error.</p> <p>To get the block that caused this error, call <code>block.ignore_error_block</code> (which is the block with the middleware not or only partially applied).</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(self, block: Block, error: Exception):\n    super().__init__(start_line=block.start_line, raw=block.raw, error=error, ignore_error_block=block)\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.ParsingFailedBlock","title":"ParsingFailedBlock","text":"<pre><code>ParsingFailedBlock(\n    error,\n    start_line=None,\n    raw=None,\n    ignore_error_block=None,\n)\n</code></pre> <p>               Bases: <code>Block</code></p> <p>A block that could not be parsed due to some raised exception.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(\n    self,\n    error: Exception,\n    start_line: int | None = None,\n    raw: str | None = None,\n    ignore_error_block: Block | None = None,\n):\n    super().__init__(start_line, raw)\n    self._error = error\n    self._ignore_error_block = ignore_error_block\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.ParsingFailedBlock-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.ParsingFailedBlock.error","title":"error  <code>property</code>","text":"<pre><code>error\n</code></pre> <p>The exception that was raised during parsing.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.ParsingFailedBlock.ignore_error_block","title":"ignore_error_block  <code>property</code>","text":"<pre><code>ignore_error_block\n</code></pre> <p>The possibly faulty block when ignoring the error.</p> <p>This may be None, as it may not always be possible to ignore the error. For errors caused by middleware, this is typically the block without the middleware applied.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Preamble","title":"Preamble","text":"<pre><code>Preamble(value, start_line=None, raw=None)\n</code></pre> <p>               Bases: <code>Block</code></p> <p>Bibtex Blocks of the <code>@preamble</code> type, e.g. <code>@preamble{This is a preamble}</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(self, value: str, start_line: int | None = None, raw: str | None = None):\n    super().__init__(start_line, raw)\n    self._value = value\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Preamble-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.Preamble.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre> <p>The value of the preamble, e.g. <code>blabla</code> in <code>@preamble{blabla}</code>.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.String","title":"String","text":"<pre><code>String(key, value, start_line=None, raw=None)\n</code></pre> <p>               Bases: <code>Block</code></p> <p>Bibtex Blocks of the <code>@string</code> type, e.g. <code>@string{me = \"My Name\"}</code>.</p> Source code in <code>pybibtexer/bib/bibtexparser/model.py</code> <pre><code>def __init__(self, key: str, value: str, start_line: int | None = None, raw: str | None = None):\n    super().__init__(start_line, raw)\n    self._key = key\n    self._value = value\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.String-attributes","title":"Attributes","text":""},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.String.key","title":"key  <code>property</code> <code>writable</code>","text":"<pre><code>key\n</code></pre> <p>The key of the string, e.g. <code>me</code> in <code>@string{me = \"My Name\"}</code>.</p>"},{"location":"api-auto/bib.bibtexparser.model/#pybibtexer.bib.bibtexparser.model.String.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre> <p>The value of the string, e.g. <code>\"My Name\"</code> in <code>@string{me = \"My Name\"}</code>.</p>"},{"location":"api-auto/bib.bibtexparser.splitter/","title":"bib.bibtexparser.splitter","text":""},{"location":"api-auto/bib.bibtexparser.splitter/#pybibtexer.bib.bibtexparser.splitter-classes","title":"Classes","text":""},{"location":"api-auto/bib.bibtexparser.splitter/#pybibtexer.bib.bibtexparser.splitter.Splitter","title":"Splitter","text":"<pre><code>Splitter()\n</code></pre> <p>Splitter class to split standardizing bib data list to library.</p> <p>Attributes:</p> Name Type Description <code>regex_block_type</code> <p>Regular expression to match block type.</p> Source code in <code>pybibtexer/bib/bibtexparser/splitter.py</code> <pre><code>def __init__(self):\n    self.regex_block_type = re.compile(r\"@([a-zA-Z]+){\")\n</code></pre>"},{"location":"api-auto/bib.bibtexparser.splitter/#pybibtexer.bib.bibtexparser.splitter.Splitter-functions","title":"Functions","text":""},{"location":"api-auto/bib.bibtexparser.splitter/#pybibtexer.bib.bibtexparser.splitter.Splitter.splitter","title":"splitter","text":"<pre><code>splitter(data_list, implicit_coments)\n</code></pre> <p>Split standardizing bib data list to library.</p> Source code in <code>pybibtexer/bib/bibtexparser/splitter.py</code> <pre><code>def splitter(self, data_list: list[str], implicit_coments: list[list[str]]):\n    \"\"\"Split standardizing bib data list to library.\"\"\"\n    _blocks = []\n\n    _blocks.extend([ImplicitComment(i[0]) for i in implicit_coments if i])\n\n    implicit_comment_blocks = []\n    explicit_comment_blocks = []\n    string_blocks = []\n    preamble_blocks = []\n    entry_blocks = []\n\n    # Initialize\n    data_list = \"\".join(data_list).splitlines(keepends=True)\n    data_list = [line for line in data_list if line.strip()]\n\n    line_index, len_data = 0, len(data_list)\n    while line_index &lt; len_data:\n        line = data_list[line_index]\n        line_index += 1\n\n        if not (mch_block := self.regex_block_type.search(line)):\n            implicit_comment_blocks.append(ImplicitComment(line, line_index))\n            continue\n\n        block_type = mch_block.group(1)\n        if block_type == \"comment\":\n            block, line_index = self._splitter_comment(block_type, line, line_index, len_data, data_list)\n            if isinstance(block, Block):\n                explicit_comment_blocks.append(block)\n            elif isinstance(block, str):\n                implicit_comment_blocks.append(ImplicitComment(block, line_index - 1))\n\n        elif block_type == \"string\":\n            block, line_index = self._splitter_string(block_type, line, line_index, len_data, data_list)\n            if isinstance(block, Block):\n                string_blocks.append(block)\n            elif isinstance(block, str):\n                implicit_comment_blocks.append(ImplicitComment(block, line_index - 1))\n\n        elif block_type == \"preamble\":\n            block, line_index = self._splitter_preamble(block_type, line, line_index, len_data, data_list)\n            if isinstance(block, Block):\n                preamble_blocks.append(block)\n            elif isinstance(block, str):\n                implicit_comment_blocks.append(ImplicitComment(block, line_index - 1))\n\n        else:\n            block, line_index, temp = self._splitter_entry(block_type, line, line_index, len_data, data_list)\n            entry_blocks.append(block)\n            implicit_comment_blocks.extend(temp)\n\n    _blocks.extend(implicit_comment_blocks)\n    _blocks.extend(explicit_comment_blocks)\n    _blocks.extend(string_blocks)\n    _blocks.extend(preamble_blocks)\n    _blocks.extend(entry_blocks)\n    return Library(_blocks)\n</code></pre>"},{"location":"api-auto/bib.core.convert_library_to_library/","title":"bib.core.convert_library_to_library","text":""},{"location":"api-auto/bib.core.convert_library_to_library/#pybibtexer.bib.core.convert_library_to_library-classes","title":"Classes","text":""},{"location":"api-auto/bib.core.convert_library_to_library/#pybibtexer.bib.core.convert_library_to_library.ConvertLibrayToLibrary","title":"ConvertLibrayToLibrary","text":"<pre><code>ConvertLibrayToLibrary(options={})\n</code></pre> <p>Convert library to library.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[str, Any]</code> <p>Options. Default is {}.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>choose_abbr_zotero_save</code> <code>str</code> <p>Choose \"abbr\", \"zotero\", or \"save\". Default is \"save\".</p> Source code in <code>pybibtexer/bib/core/convert_library_to_library.py</code> <pre><code>def __init__(self, options: dict[str, Any] = {}) -&gt; None:\n    self.choose_abbr_zotero_save = options.get(\"choose_abbr_zotero_save\", \"save\")\n\n    self._middleware_library_library = MiddlewaresLibraryToLibrary(options)\n</code></pre>"},{"location":"api-auto/bib.core.convert_library_to_str/","title":"bib.core.convert_library_to_str","text":""},{"location":"api-auto/bib.core.convert_library_to_str/#pybibtexer.bib.core.convert_library_to_str-classes","title":"Classes","text":""},{"location":"api-auto/bib.core.convert_library_to_str/#pybibtexer.bib.core.convert_library_to_str.ConvertLibrayToStr","title":"ConvertLibrayToStr","text":"<pre><code>ConvertLibrayToStr(options)\n</code></pre> <p>Convert library to str.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[str, Any]</code> <p>Options. Default is {}.</p> required <p>Attributes:</p> Name Type Description <code>is_standardize_library</code> <code>bool</code> <p>Is standardize library. Default is False.</p> <code>empty_entry_cite_keys</code> <code>bool</code> <p>Empty entry cite keys. Default is False.</p> <code>add_index_to_entries</code> <code>bool</code> <p>Add index to entries. Default is False.</p> <code>entries_necessary</code> <code>bool</code> <p>Is the entries are necessary in the bib file.</p> Source code in <code>pybibtexer/bib/core/convert_library_to_str.py</code> <pre><code>def __init__(self, options: dict[str, Any]):\n    self.is_standardize_library = options.get(\"is_standardize_library\", False)\n    self.empty_entry_cite_keys = options.get(\"empty_entry_cite_keys\", False)\n    self.add_index_to_entries = options.get(\"add_index_to_entries\", False)\n    self.entries_necessary = options.get(\"entries_necessary\", True)\n\n    self.options = options\n</code></pre>"},{"location":"api-auto/bib.core.convert_library_to_str/#pybibtexer.bib.core.convert_library_to_str.ConvertLibrayToStr-functions","title":"Functions","text":""},{"location":"api-auto/bib.core.convert_library_to_str/#pybibtexer.bib.core.convert_library_to_str.ConvertLibrayToStr.generate_str","title":"generate_str","text":"<pre><code>generate_str(library, bibtex_format=None)\n</code></pre> <p>Serialize a BibTeX database.</p> <p>:param library: BibTeX database to serialize. :param bibtex_format: Customized BibTeX format to use (optional).</p> Source code in <code>pybibtexer/bib/core/convert_library_to_str.py</code> <pre><code>def generate_str(self, library: Library | list[Block], bibtex_format: BibtexFormat | None = None) -&gt; list[str]:\n    \"\"\"Serialize a BibTeX database.\n\n    :param library: BibTeX database to serialize.\n    :param bibtex_format: Customized BibTeX format to use (optional).\n    \"\"\"\n    # --------- --------- --------- #\n    if not isinstance(library, Library):\n        library = Library(library)\n\n    # standardizer\n    if self.is_standardize_library:\n        library = ConvertLibrayToLibrary(self.options).generate_single_library(library)\n\n    # --------- --------- --------- #\n    library = MiddlewaresLibraryToStr(self.options).functions(library)\n\n    # --------- --------- --------- #\n    if bibtex_format is None:\n        bibtex_format = BibtexFormat()\n\n    if bibtex_format.value_column == \"auto\":\n        auto_val: int = self._calculate_auto_value_align(library)\n        # Copy the format instance to avoid modifying the original\n        # (which would be bad if the format is used for multiple libraries)\n        bibtex_format = deepcopy(bibtex_format)\n        bibtex_format.value_column = auto_val\n\n    # --------- --------- --------- #\n    if self.entries_necessary:\n        if not library.entries:\n            return []\n\n    data_list = []\n    j = 0\n    for i, block in enumerate(library.blocks):\n        if self.add_index_to_entries and isinstance(block, Entry):\n            data_list.append(f\"% {j + 1}\\n\")\n            j += 1\n\n        # Get str representation of block\n        pieces = self._treat_block(bibtex_format, block)\n        data_list.extend(pieces)\n\n        # Separate Blocks\n        if i &lt; len(library.blocks) - 1:\n            data_list.append(bibtex_format.block_separator)\n    return data_list\n</code></pre>"},{"location":"api-auto/bib.core.convert_str_to_library/","title":"bib.core.convert_str_to_library","text":""},{"location":"api-auto/bib.core.convert_str_to_library/#pybibtexer.bib.core.convert_str_to_library-classes","title":"Classes","text":""},{"location":"api-auto/bib.core.convert_str_to_library/#pybibtexer.bib.core.convert_str_to_library.ConvertStrToLibrary","title":"ConvertStrToLibrary","text":"<pre><code>ConvertStrToLibrary(options={})\n</code></pre> <p>Convert str to library.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[str, Any]</code> <p>Options. Default is {}.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>is_standardize_bib</code> <code>bool</code> <p>Is standardize bib. Default is True.</p> Source code in <code>pybibtexer/bib/core/convert_str_to_library.py</code> <pre><code>def __init__(self, options: dict[str, Any] = {}) -&gt; None:\n    self.is_standardize_bib = options.get(\"is_standardize_bib\", True)\n\n    self.options = options\n</code></pre>"},{"location":"api-auto/bib.core.convert_str_to_str/","title":"bib.core.convert_str_to_str","text":""},{"location":"api-auto/bib.core.convert_str_to_str/#pybibtexer.bib.core.convert_str_to_str-classes","title":"Classes","text":""},{"location":"api-auto/bib.core.convert_str_to_str/#pybibtexer.bib.core.convert_str_to_str.ConvertStrToStr","title":"ConvertStrToStr","text":"<pre><code>ConvertStrToStr(options={})\n</code></pre> <p>Convert str to str.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[str, Any]</code> <p>Options. Default is {}.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>default_additional_field_list</code> <code>list[str]</code> <p>Default additional field list. Default is [].</p> Source code in <code>pybibtexer/bib/core/convert_str_to_str.py</code> <pre><code>def __init__(self, options: dict[str, Any] = {}) -&gt; None:\n    self.default_additional_field_list = options.get(\"default_additional_field_list\", [])\n\n    self.options = options\n</code></pre>"},{"location":"api-auto/main.basic_input/","title":"main.basic_input","text":""},{"location":"api-auto/main.basic_input/#pybibtexer.main.basic_input-classes","title":"Classes","text":""},{"location":"api-auto/main.basic_input/#pybibtexer.main.basic_input.BasicInput","title":"BasicInput","text":"<pre><code>BasicInput(options)\n</code></pre> <p>Basic input.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[str, Any]</code> <p>Options.</p> required <p>Attributes:</p> Name Type Description <code>full_abbr_article_dict</code> <code>dict[str, str]</code> <p>Full abbr article dict.</p> <code>full_abbr_inproceedings_dict</code> <code>dict[str, str]</code> <p>Full abbr inproceedings dict.</p> <code>full_names_in_json</code> <code>str</code> <p>Full names in json.</p> <code>abbr_names_in_json</code> <code>str</code> <p>Abbr names in json.</p> <code>abbr_article_pattern_dict</code> <code>dict</code> <p>Pre-compiled regex patterns for journal name matching</p> <code>abbr_inproceedings_pattern_dict</code> <code>dict</code> <p>Pre-compiled regex patterns for conference name matching</p> <code>full_biblatex_bib</code> <code>str</code> <p>Path to the BibLaTex file</p> <code>options</code> <code>dict[str, Any]</code> <p>Options.</p> Notes <p>full_json_c (str): User-provided JSON file containing conference data. full_json_j (str): User-provided JSON file containing journal data.</p> <p>Initialize the processor with configuration options.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[str, Any]</code> <p>Configuration dictionary containing processing parameters</p> required Source code in <code>pybibtexer/main/basic_input.py</code> <pre><code>def __init__(self, options: dict[str, Any]) -&gt; None:\n    \"\"\"Initialize the processor with configuration options.\n\n    Args:\n        options: Configuration dictionary containing processing parameters\n    \"\"\"\n    # Load special abbreviations for conferences and journals from built-in templates\n    special_abbr_dict_c = self._process_build_in_json(\"conferences_special.json\")\n    special_abbr_dict_j = self._process_build_in_json(\"journals_special.json\")\n\n    # Load default abbreviations for conferences and journals from built-in templates\n    default_abbr_dict_c = self._process_build_in_json(\"conferences.json\")\n    default_abbr_dict_j = self._process_build_in_json(\"journals.json\")\n\n    # Load user-defined abbreviations from provided JSON files\n    full_json_c, full_json_j = options.get(\"full_json_c\", \"\"), options.get(\"full_json_j\", \"\")\n    user_abbr_dict_c, user_abbr_dict_j = process_user_conferences_journals_json(full_json_c, full_json_j)\n\n    # Merge dictionaries with precedence: user &gt; default\n    full_abbr_article_dict = {**default_abbr_dict_j, **user_abbr_dict_j}\n    full_abbr_inproceedings_dict = {**default_abbr_dict_c, **user_abbr_dict_c}\n\n    # TODO: Whether to check?\n    # Check for duplicate acronyms and abbreviations in the dictionaries\n    # check = CheckAcronymAbbrAndFullDict()\n    # full_abbr_article_dict = check.length_dupicate_match(full_abbr_article_dict)[0]\n    # full_abbr_inproceedings_dict = check.length_dupicate_match(full_abbr_inproceedings_dict)[0]\n\n    # Parse new abbreviations from BibLaTex file\n    biblatex_dict_c, biblatex_dict_j = self._process_biblatex(options.get(\"full_biblatex_bib\", \"\"))\n\n    # Merge dictionaries with precedence: user &gt; default &gt; new &gt; special\n    full_abbr_article_dict = {**special_abbr_dict_j, **biblatex_dict_j, **full_abbr_article_dict}\n    full_abbr_inproceedings_dict = {**special_abbr_dict_c, **biblatex_dict_c, **full_abbr_inproceedings_dict}\n\n    # Convert to strict ordered dictionaries to maintain consistent ordering\n    full_abbr_article_dict = StrictOrderedDict(full_abbr_article_dict)\n    full_abbr_inproceedings_dict = StrictOrderedDict(full_abbr_inproceedings_dict)\n\n    # Define JSON field names for full and abbreviated names\n    full_names_in_json = \"names_full\"\n    abbr_names_in_json = \"names_abbr\"\n\n    # Pre-compile regex patterns for efficient text matching\n    abbr_article_pattern_dict, abbr_inproceedings_pattern_dict = self.abbr_article_inproceedings_pattern(\n        full_abbr_article_dict, full_abbr_inproceedings_dict, full_names_in_json, abbr_names_in_json\n    )\n\n    # Convert pattern dictionaries to strict ordered dictionaries\n    abbr_article_pattern_dict = StrictOrderedDict(abbr_article_pattern_dict)\n    abbr_inproceedings_pattern_dict = StrictOrderedDict(abbr_inproceedings_pattern_dict)\n\n    # Store all configurations in options for later use by other methods\n    options[\"full_abbr_article_dict\"] = full_abbr_article_dict\n    options[\"full_abbr_inproceedings_dict\"] = full_abbr_inproceedings_dict\n    options[\"full_names_in_json\"] = full_names_in_json\n    options[\"abbr_names_in_json\"] = abbr_names_in_json\n    options[\"abbr_article_pattern_dict\"] = abbr_article_pattern_dict\n    options[\"abbr_inproceedings_pattern_dict\"] = abbr_inproceedings_pattern_dict\n\n    self.options = options\n</code></pre>"},{"location":"api-auto/main.basic_input/#pybibtexer.main.basic_input.BasicInput-functions","title":"Functions","text":""},{"location":"api-auto/main.basic_input/#pybibtexer.main.basic_input.BasicInput.abbr_article_inproceedings_pattern","title":"abbr_article_inproceedings_pattern  <code>staticmethod</code>","text":"<pre><code>abbr_article_inproceedings_pattern(\n    full_abbr_article_dict,\n    full_abbr_inproceedings_dict,\n    full_names_in_json,\n    abbr_names_in_json,\n)\n</code></pre> <p>Pre-compile regex patterns for journal and conference name matching.</p> <p>Parameters:</p> Name Type Description Default <code>full_abbr_article_dict</code> <code>StrictOrderedDict</code> <p>dictionary containing journal abbreviations and their full names</p> required <code>full_abbr_inproceedings_dict</code> <code>StrictOrderedDict</code> <p>dictionary containing conference abbreviations and their full names</p> required <code>full_names_in_json</code> <code>str</code> <p>Key for full names in the dictionary</p> required <code>abbr_names_in_json</code> <code>str</code> <p>Key for abbreviation names in the dictionary</p> required <p>Returns:</p> Type Description <code>tuple[dict[str, dict[str, Any]], dict[str, dict[str, dict[str, Any]]]]</code> <p>Tuple of two dictionaries containing pre-compiled regex patterns for journals and conferences</p> Source code in <code>pybibtexer/main/basic_input.py</code> <pre><code>@staticmethod\ndef abbr_article_inproceedings_pattern(\n    full_abbr_article_dict: StrictOrderedDict,\n    full_abbr_inproceedings_dict: StrictOrderedDict,\n    full_names_in_json: str,\n    abbr_names_in_json: str,\n) -&gt; tuple[dict[str, dict[str, Any]], dict[str, dict[str, dict[str, Any]]]]:\n    \"\"\"Pre-compile regex patterns for journal and conference name matching.\n\n    Args:\n        full_abbr_article_dict: dictionary containing journal abbreviations and their full names\n        full_abbr_inproceedings_dict: dictionary containing conference abbreviations and their full names\n        full_names_in_json: Key for full names in the dictionary\n        abbr_names_in_json: Key for abbreviation names in the dictionary\n\n    Returns:\n        Tuple of two dictionaries containing pre-compiled regex patterns for journals and conferences\n    \"\"\"\n\n    def _create_pattern_dict(abbr_dict: StrictOrderedDict) -&gt; dict[str, dict[str, Any]]:\n        \"\"\"Helper function to create pattern dictionary for a given abbreviation dictionary.\"\"\"\n        pattern_dict = {}\n        for abbr, abbr_info in abbr_dict.items():\n            # Get all name variations and combine with abbreviation\n            full_names = abbr_info.get(full_names_in_json, [])\n            long_abbrs = abbr_info.get(abbr_names_in_json, [])\n            all_names = [*full_names, *long_abbrs, abbr]\n            all_names = [m.lower() for m in all_names]\n\n            # Create pre-compiled regex pattern for exact matching\n            pattern_dict[abbr] = {\n                \"pattern\": re.compile(rf\"^({'|'.join(all_names)})$\", flags=re.I),\n                \"names\": all_names,\n            }\n        return pattern_dict\n\n    abbr_article_pattern_dict = _create_pattern_dict(full_abbr_article_dict)\n    abbr_inproceedings_pattern_dict = _create_pattern_dict(full_abbr_inproceedings_dict)\n\n    return abbr_article_pattern_dict, abbr_inproceedings_pattern_dict\n</code></pre>"},{"location":"api-auto/main.basic_input/#pybibtexer.main.basic_input-functions","title":"Functions","text":""},{"location":"api-auto/main.python_run_bib/","title":"main.python_run_bib","text":""},{"location":"api-auto/main.python_run_bib/#pybibtexer.main.python_run_bib-classes","title":"Classes","text":""},{"location":"api-auto/main.python_run_bib/#pybibtexer.main.python_run_bib.PythonRunBib","title":"PythonRunBib","text":"<pre><code>PythonRunBib(options)\n</code></pre> <p>               Bases: <code>BasicInput</code></p> <p>Python bib.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[str, Any]</code> <p>Options.</p> required <p>Attributes:</p> Name Type Description <code>choose_abbr_zotero_save</code> <code>str</code> <p>Selected bibliography purpose (\"abbr\", \"zotero\", or \"save\")</p> Source code in <code>pybibtexer/main/python_run_bib.py</code> <pre><code>def __init__(self, options: dict[str, Any]) -&gt; None:\n    options[\"choose_abbr_zotero_save\"] = options.get(\"choose_abbr_zotero_save\", \"save\")\n    super().__init__(options)\n</code></pre>"},{"location":"api-auto/main.python_writers/","title":"main.python_writers","text":""},{"location":"api-auto/main.python_writers/#pybibtexer.main.python_writers-classes","title":"Classes","text":""},{"location":"api-auto/main.python_writers/#pybibtexer.main.python_writers.PythonWriters","title":"PythonWriters","text":"<pre><code>PythonWriters(options)\n</code></pre> <p>               Bases: <code>BasicInput</code></p> <p>Python writers for generating BibTeX files with various formatting options.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>dict[str, Any]</code> <p>Configuration options for BibTeX generation. - is_sort_entry_fields (bool): Whether to sort entry fields (default: True) - is_sort_blocks (bool): Whether to sort bibliography blocks (default: True) - sort_entries_by_field_keys_reverse (bool): Reverse sort order for entries (default: True) - choose_abbr_zotero_save (str): Source selection - \"abbr\", \"zotero\", or \"save\" (default: \"save\")</p> required <p>Attributes:</p> Name Type Description <code>choose_abbr_zotero_save</code> <code>str</code> <p>Selected bibliography purpose (\"abbr\", \"zotero\", or \"save\")</p> <code>bib_name_for_abbr</code> <code>str</code> <p>Filename for abbreviated bibliography (default: \"abbr.bib\")</p> <code>bib_name_for_zotero</code> <code>str</code> <p>Filename for Zotero bibliography (default: \"zotero.bib\")</p> <code>bib_name_for_save</code> <code>str</code> <p>Filename for saved bibliography (default: \"save.bib\")</p> <code>join_flag_in_http</code> <code>str</code> <p>The join flag for HTTP-related formatting (default: \" | \" or \" |\\n\")</p> <code>display_www_google_connected_scite</code> <code>list[str]</code> <p>Display options selection from [\"www\", \"google\", \"connected\", \"scite\"]</p> <code>bibtex_format_indent</code> <code>str</code> <p>Indentation string for BibTeX formatting (default: \"  \")</p> <code>bibtex_format_trailing_comma</code> <code>bool</code> <p>Whether to include trailing commas in BibTeX entries (default: True)</p> <code>bibtex_format_block_separator</code> <code>str</code> <p>Separator between BibTeX blocks (default: \"\")</p> Source code in <code>pybibtexer/main/python_writers.py</code> <pre><code>def __init__(self, options: dict[str, Any]) -&gt; None:\n    # Set default options if not provided\n    options[\"choose_abbr_zotero_save\"] = options.get(\"choose_abbr_zotero_save\", \"save\")\n    options[\"is_sort_entry_fields\"] = options.get(\"is_sort_entry_fields\", True)\n    options[\"is_sort_blocks\"] = options.get(\"is_sort_blocks\", True)\n    options[\"sort_entries_by_field_keys_reverse\"] = options.get(\"sort_entries_by_field_keys_reverse\", True)\n    super().__init__(options)\n\n    # Initialize bibliography source filenames\n    self.bib_name_for_abbr = options.get(\"bib_name_for_abbr\", \"abbr.bib\")\n    self.bib_name_for_zotero = options.get(\"bib_name_for_zotero\", \"zotero.bib\")\n    self.bib_name_for_save = options.get(\"bib_name_for_save\", \"save.bib\")\n\n    self.join_flag_in_http = options.get(\"join_flag_in_http\", \" | \")  # \" |\\n\"\n\n    # Initialize display options\n    self.display_www_google_connected_scite = options.get(\n        \"display_www_google_connected_scite\", [\"www\", \"google\", \"connected\", \"scite\"]\n    )\n\n    # Initialize BibTeX formatting options\n    self.bibtex_format_indent = options.get(\"bibtex_format_indent\", \"  \")\n    self.bibtex_format_trailing_comma = options.get(\"bibtex_format_trailing_comma\", True)\n    self.bibtex_format_block_separator = options.get(\"bibtex_format_block_separator\", \"\")\n\n    # Create and configure BibtexFormat object\n    bibtex_format = BibtexFormat()\n    bibtex_format.indent = self.bibtex_format_indent\n    bibtex_format.block_separator = self.bibtex_format_block_separator\n    bibtex_format.trailing_comma = self.bibtex_format_trailing_comma\n    self._bibtex_format: BibtexFormat = bibtex_format\n</code></pre>"},{"location":"api-auto/main.python_writers/#pybibtexer.main.python_writers.PythonWriters-functions","title":"Functions","text":""},{"location":"api-auto/main.python_writers/#pybibtexer.main.python_writers.PythonWriters.write_to_file","title":"write_to_file","text":"<pre><code>write_to_file(\n    original_data,\n    file_name,\n    write_flag=\"w\",\n    path_storage=None,\n    check=True,\n    delete_first_empty=True,\n    delete_last_empty=True,\n    compulsory=False,\n    delete_original_file=False,\n)\n</code></pre> <p>Write.</p> <p>Parameters:</p> Name Type Description Default <code>original_data</code> <code>Union[Library, list[Block], list[str]]</code> <p>data</p> required <code>file_name</code> <code>str</code> <p>file name</p> required <code>write_flag</code> <code>str = \"w\"</code> <p>write flag</p> <code>'w'</code> <code>path_storage</code> <code>Optional[str] = None</code> <p>path storage</p> <code>None</code> <code>check</code> <code>bool = True</code> <p>check</p> <code>True</code> <code>delete_first_empty</code> <code>bool = True</code> <p>delete first empty</p> <code>True</code> <code>delete_last_empty</code> <code>bool = True</code> <p>delete last empty</p> <code>True</code> <code>compulsory</code> <code>bool = False</code> <p>compulsory</p> <code>False</code> <code>delete_original_file</code> <code>bool = False</code> <p>delete original file</p> <code>False</code> Source code in <code>pybibtexer/main/python_writers.py</code> <pre><code>def write_to_file(\n    self,\n    original_data: Library | list[Block] | list[str],\n    file_name: str,\n    write_flag: str = \"w\",\n    path_storage: str | None = None,\n    check: bool = True,\n    delete_first_empty: bool = True,\n    delete_last_empty: bool = True,\n    compulsory: bool = False,\n    delete_original_file: bool = False,\n) -&gt; None:\n    \"\"\"Write.\n\n    Args:\n        original_data (Union[Library, list[Block], list[str]]): data\n        file_name (str): file name\n        write_flag (str = \"w\"): write flag\n        path_storage (Optional[str] = None): path storage\n        check (bool = True): check\n        delete_first_empty (bool = True): delete first empty\n        delete_last_empty (bool = True): delete last empty\n        compulsory (bool = False): compulsory\n        delete_original_file (bool = False): delete original file\n\n    \"\"\"\n    _options = {}\n    _options.update(self.options)\n    _library_str = ConvertLibrayToStr(_options)\n\n    if isinstance(original_data, Library):\n        data_list = _library_str.generate_str(original_data, self._bibtex_format)\n    elif isinstance(original_data, list):\n        if all(isinstance(line, str) for line in original_data):\n            data_list = [line for line in original_data if isinstance(line, str)]\n        else:\n            data_list = [line for line in original_data if isinstance(line, Block)]\n            data_list = _library_str.generate_str(data_list, self._bibtex_format)\n\n    write_list(\n        data_list,\n        file_name,\n        write_flag,\n        path_storage,\n        check,\n        delete_first_empty,\n        delete_last_empty,\n        compulsory,\n        delete_original_file,\n    )\n    return None\n</code></pre>"},{"location":"api-auto/main.python_writers/#pybibtexer.main.python_writers.PythonWriters.write_to_str","title":"write_to_str","text":"<pre><code>write_to_str(library)\n</code></pre> <p>Serialize a BibTeX database to a string.</p> <p>Parameters:</p> Name Type Description Default <code>library</code> <code>Library | list[Block]</code> <p>BibTeX database to serialize.</p> required Source code in <code>pybibtexer/main/python_writers.py</code> <pre><code>def write_to_str(self, library: Library | list[Block]) -&gt; list[str]:\n    \"\"\"Serialize a BibTeX database to a string.\n\n    Args:\n        library (Library | list[Block]): BibTeX database to serialize.\n\n    \"\"\"\n    return ConvertLibrayToStr(self.options).generate_str(library, self._bibtex_format)\n</code></pre>"},{"location":"api-auto/main.utils/","title":"main.utils","text":""},{"location":"api-auto/main.utils/#pybibtexer.main.utils-classes","title":"Classes","text":""},{"location":"api-auto/main.utils/#pybibtexer.main.utils.CheckAcronymAbbrAndFullDict","title":"CheckAcronymAbbrAndFullDict","text":"<pre><code>CheckAcronymAbbrAndFullDict(\n    names_abbr=\"names_abbr\", names_full=\"names_full\"\n)\n</code></pre> <p>Checker for acronym, abbreviation and full form dictionaries.</p> <p>Validates and processes dictionary data containing acronyms with their corresponding abbreviations and full forms.</p> <p>Attributes:</p> Name Type Description <code>names_abbr</code> <code>str</code> <p>Key name for abbreviations in the dictionary.</p> <code>names_full</code> <code>str</code> <p>Key name for full forms in the dictionary.</p> <p>Initializes the checker with field names.</p> <p>Parameters:</p> Name Type Description Default <code>names_abbr</code> <code>str</code> <p>Key name for abbreviations, defaults to \"names_abbr\".</p> <code>'names_abbr'</code> <code>names_full</code> <code>str</code> <p>Key name for full forms, defaults to \"names_full\".</p> <code>'names_full'</code> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def __init__(self, names_abbr: str = \"names_abbr\", names_full: str = \"names_full\") -&gt; None:\n    \"\"\"Initializes the checker with field names.\n\n    Args:\n        names_abbr: Key name for abbreviations, defaults to \"names_abbr\".\n        names_full: Key name for full forms, defaults to \"names_full\".\n    \"\"\"\n    self.names_abbr = names_abbr\n    self.names_full = names_full\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.CheckAcronymAbbrAndFullDict-functions","title":"Functions","text":""},{"location":"api-auto/main.utils/#pybibtexer.main.utils.CheckAcronymAbbrAndFullDict.compare_and_return_only_in_new","title":"compare_and_return_only_in_new","text":"<pre><code>compare_and_return_only_in_new(json_old, json_new)\n</code></pre> <p>Compares old and new JSON data to find newly added items.</p> <p>Parameters:</p> Name Type Description Default <code>json_old</code> <code>dict</code> <p>Old JSON data as dictionary.</p> required <code>json_new</code> <code>dict</code> <p>New JSON data as dictionary.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing keys that only exist in new data.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def compare_and_return_only_in_new(self, json_old: dict, json_new: dict) -&gt; dict:\n    \"\"\"Compares old and new JSON data to find newly added items.\n\n    Args:\n        json_old: Old JSON data as dictionary.\n        json_new: New JSON data as dictionary.\n\n    Returns:\n        dict: Dictionary containing keys that only exist in new data.\n    \"\"\"\n    # Find keys that only exist in new JSON\n    keys_only_in_new = sorted(set(json_new.keys()) - set(json_old.keys()))\n    new_only_data = {key: json_new[key] for key in keys_only_in_new}\n\n    # Find common keys between old and new JSON\n    common_keys = set(json_old.keys()) &amp; set(json_new.keys())\n\n    # Check each common key for new items using pattern matching\n    for key in sorted(common_keys):\n        for flag in [self.names_full]:\n            old_items = [item.lower() for item in json_old[key][flag]]\n            old_items = [item.replace(\"(\", \"\").replace(\")\", \"\") for item in old_items]\n\n            new_items = [item.lower() for item in json_new[key][flag]]\n            new_items = [item.replace(\"(\", \"\").replace(\")\", \"\") for item in new_items]\n\n            self._old_match_new(json_old, key, flag, old_items, new_items)\n\n    # Return keys that only exist in new data\n    return new_only_data\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.CheckAcronymAbbrAndFullDict.length_dupicate_match","title":"length_dupicate_match","text":"<pre><code>length_dupicate_match(dict_data)\n</code></pre> <p>Performs comprehensive validation on dictionary data.</p> <p>Executes three validation steps: length validation, duplicate checking, and mutual pattern matching.</p> <p>Parameters:</p> Name Type Description Default <code>dict_data</code> <code>dict[str, dict[str, list[str]]]</code> <p>Dictionary containing acronym data with abbreviations       and full forms.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[dict[str, dict[str, list[str]]], list[str]]</code> <p>Validated dictionary and list of acronyms with matches.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def length_dupicate_match(\n    self, dict_data: dict[str, dict[str, list[str]]]\n) -&gt; tuple[dict[str, dict[str, list[str]]], list[str]]:\n    \"\"\"Performs comprehensive validation on dictionary data.\n\n    Executes three validation steps: length validation, duplicate checking,\n    and mutual pattern matching.\n\n    Args:\n        dict_data: Dictionary containing acronym data with abbreviations\n                  and full forms.\n\n    Returns:\n        tuple: Validated dictionary and list of acronyms with matches.\n    \"\"\"\n    dict_data = self._validate_length(dict_data)\n    dict_data = self._check_duplicate(dict_data)\n\n    # Check for matching patterns in both abbreviations and full forms\n    dict_data, abbr_matches = self._mutually_check_match(dict_data, self.names_abbr)\n    dict_data, full_matches = self._mutually_check_match(dict_data, self.names_full)\n    matches = sorted(set(abbr_matches).union(full_matches))\n    return dict_data, matches\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict","title":"StrictOrderedDict","text":"<pre><code>StrictOrderedDict(data)\n</code></pre> <p>A dictionary that strictly maintains insertion order.</p> <p>This implementation guarantees that keys, values, and items will always be returned in the exact order they were inserted, regardless of Python version or internal dictionary implementation changes.</p> <p>Attributes:</p> Name Type Description <code>_keys</code> <p>List maintaining the order of key insertion.</p> <code>_data</code> <p>Dictionary storing the actual key-value pairs.</p> <p>Initializes the StrictOrderedDict with optional initial data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Optional iterable of (key, value) pairs to initialize the dictionary.   If provided, must be an iterable containing exactly two-element   tuples or lists representing key-value pairs.</p> required Example <p>sod = StrictOrderedDict() sod = StrictOrderedDict([('a', 1), ('b', 2)])</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def __init__(self, data: dict) -&gt; None:\n    \"\"\"Initializes the StrictOrderedDict with optional initial data.\n\n    Args:\n        data: Optional iterable of (key, value) pairs to initialize the dictionary.\n              If provided, must be an iterable containing exactly two-element\n              tuples or lists representing key-value pairs.\n\n    Example:\n        &gt;&gt;&gt; sod = StrictOrderedDict()\n        &gt;&gt;&gt; sod = StrictOrderedDict([('a', 1), ('b', 2)])\n    \"\"\"\n    self._keys = []  # Maintains insertion order of keys\n    self._data = {}  # Stores the actual key-value mappings\n\n    if data:\n        for k, v in data.items():\n            self[k] = v\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict-functions","title":"Functions","text":""},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict.__contains__","title":"__contains__","text":"<pre><code>__contains__(key)\n</code></pre> <p>Support key in dict syntax.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check for existence.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if key exists in the dictionary, False otherwise.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    \"\"\"Support key in dict syntax.\n\n    Args:\n        key: The key to check for existence.\n\n    Returns:\n        True if key exists in the dictionary, False otherwise.\n    \"\"\"\n    return key in self._data\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Retrieves the value associated with the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to look up.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value associated with the key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the dictionary.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Retrieves the value associated with the given key.\n\n    Args:\n        key: The key to look up.\n\n    Returns:\n        The value associated with the key.\n\n    Raises:\n        KeyError: If the key is not found in the dictionary.\n    \"\"\"\n    return self._data[key]\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Support len(dict) syntax.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of items in the dictionary.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Support len(dict) syntax.\n\n    Returns:\n        The number of items in the dictionary.\n    \"\"\"\n    return len(self._data)\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns a string representation of the dictionary.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation showing all key-value pairs in insertion order,</p> <code>str</code> <p>formatted like a standard Python dictionary.</p> Example <p>sod = StrictOrderedDict([('x', 10), ('y', 20)]) print(sod)</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Returns a string representation of the dictionary.\n\n    Returns:\n        A string representation showing all key-value pairs in insertion order,\n        formatted like a standard Python dictionary.\n\n    Example:\n        &gt;&gt;&gt; sod = StrictOrderedDict([('x', 10), ('y', 20)])\n        &gt;&gt;&gt; print(sod)\n        {'x': 10, 'y': 20}\n    \"\"\"\n    items = [f\"'{k}': {v}\" for k, v in self.items()]\n    return \"{\" + \", \".join(items) + \"}\"\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Sets a key-value pair, maintaining insertion order for new keys.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to set or update.</p> required <code>value</code> <code>Any</code> <p>The value to associate with the key.</p> required Note <p>If the key is new, it is added to the end of the insertion order. If the key exists, its value is updated but its position remains unchanged.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def __setitem__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a key-value pair, maintaining insertion order for new keys.\n\n    Args:\n        key: The key to set or update.\n        value: The value to associate with the key.\n\n    Note:\n        If the key is new, it is added to the end of the insertion order.\n        If the key exists, its value is updated but its position remains unchanged.\n    \"\"\"\n    if key not in self._data:\n        self._keys.append(key)  # Only add new keys to maintain order\n\n    self._data[key] = value\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict.get","title":"get","text":"<pre><code>get(key, default=None)\n</code></pre> <p>Safely get a value by key, returning default if key doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to look up.</p> required <code>default</code> <code>Any</code> <p>Value to return if key is not found. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value associated with the key, or default if key doesn't exist.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Safely get a value by key, returning default if key doesn't exist.\n\n    Args:\n        key: The key to look up.\n        default: Value to return if key is not found. Defaults to None.\n\n    Returns:\n        The value associated with the key, or default if key doesn't exist.\n    \"\"\"\n    return self._data.get(key, default)\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Returns all key-value pairs in insertion order.</p> <p>Returns:</p> Type Description <code>list[tuple[str, Any]]</code> <p>A list of (key, value) tuples in the order they were inserted.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def items(self) -&gt; list[tuple[str, Any]]:\n    \"\"\"Returns all key-value pairs in insertion order.\n\n    Returns:\n        A list of (key, value) tuples in the order they were inserted.\n    \"\"\"\n    return [(k, self._data[k]) for k in self._keys]\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Returns all keys in insertion order.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A copy of the list containing all keys in the order they were inserted.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def keys(self) -&gt; list[str]:\n    \"\"\"Returns all keys in insertion order.\n\n    Returns:\n        A copy of the list containing all keys in the order they were inserted.\n    \"\"\"\n    return self._keys.copy()\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.StrictOrderedDict.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Returns all values in key insertion order.</p> <p>Returns:</p> Type Description <code>list[Any]</code> <p>A list of values in the same order as their corresponding keys were inserted.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def values(self) -&gt; list[Any]:\n    \"\"\"Returns all values in key insertion order.\n\n    Returns:\n        A list of values in the same order as their corresponding keys were inserted.\n    \"\"\"\n    return [self._data[k] for k in self._keys]\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils-functions","title":"Functions","text":""},{"location":"api-auto/main.utils/#pybibtexer.main.utils.parse_bibtex_file","title":"parse_bibtex_file","text":"<pre><code>parse_bibtex_file(full_biblatex, entry_type='article')\n</code></pre> <p>Parse BibTeX file and extract conference or journal data.</p> <p>Parameters:</p> Name Type Description Default <code>full_biblatex</code> <code>str</code> <p>Path to the BibLaTeX file.</p> required <code>entry_type</code> <code>str</code> <p>Type of entry to parse - 'article' or 'inproceedings'.</p> <code>'article'</code> <p>Returns:</p> Type Description <code>dict[str, dict[str, list[str]]]</code> <p>Dictionary containing parsed conference or journal data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If entry_type is not 'article' or 'inproceedings'.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def parse_bibtex_file(full_biblatex: str, entry_type: str = \"article\") -&gt; dict[str, dict[str, list[str]]]:\n    \"\"\"Parse BibTeX file and extract conference or journal data.\n\n    Args:\n        full_biblatex: Path to the BibLaTeX file.\n        entry_type: Type of entry to parse - 'article' or 'inproceedings'.\n\n    Returns:\n        Dictionary containing parsed conference or journal data.\n\n    Raises:\n        ValueError: If entry_type is not 'article' or 'inproceedings'.\n    \"\"\"\n    if entry_type not in [\"article\", \"inproceedings\"]:\n        raise ValueError(\"entry_type must be 'article' or 'inproceedings'\")\n\n    config = {\n        \"article\": {\n            \"prefix\": \"J_\",\n            \"pattern\": r\"@article\\{(.*?),\\s*([^@]*)\\}\",\n            \"full_field\": \"journaltitle\",\n            \"abbr_field\": \"shortjournal\",\n        },\n        \"inproceedings\": {\n            \"prefix\": \"C_\",\n            \"pattern\": r\"@inproceedings\\{(.*?),\\s*([^@]*)\\}\",\n            \"full_field\": \"booktitle\",\n            \"abbr_field\": \"eventtitle\",\n        },\n    }\n\n    cfg = config[entry_type]\n    content = read_str(full_biblatex)\n    entries = re.findall(cfg[\"pattern\"], content, re.DOTALL)\n\n    result_dict = {}\n    for cite_key, entry_content in entries:\n        # Process only entries with the specified prefix\n        if not cite_key.startswith(cfg[\"prefix\"]):\n            continue\n\n        # Extract full and abbreviation fields\n        full_match = re.search(cfg['full_field'] + r\"\\s*=\\s*{\" + r\"(.*)\" + \"}\", entry_content)\n        abbr_match = re.search(cfg['abbr_field'] + r\"\\s*=\\s*{\" + r\"(.*)\" + \"}\", entry_content)\n\n        if not full_match:\n            continue\n\n        full = full_match.group(1).strip()\n        abbr = abbr_match.group(1).strip() if abbr_match else full\n\n        # Remove case-protection\n        full = full.replace(\"{\", \"\").replace(\"}\", \"\")\n        abbr = abbr.replace(\"{\", \"\").replace(\"}\", \"\")\n\n        parts = cite_key.split(\"_\")\n        if len(parts) &gt;= 3:\n            key = parts[1]\n\n            # Check if key already exists\n            if key in result_dict:\n                existing_entry = result_dict[key]\n\n                # Only add if full name is not already present\n                if full not in existing_entry[\"names_full\"]:\n                    existing_entry[\"names_abbr\"].append(abbr)\n                    existing_entry[\"names_full\"].append(full)\n            else:\n                # New key - add to dictionary\n                result_dict[key] = {\"names_abbr\": [abbr], \"names_full\": [full]}\n\n    return result_dict\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.process_user_conferences_journals_json","title":"process_user_conferences_journals_json","text":"<pre><code>process_user_conferences_journals_json(\n    full_json_c, full_json_j\n)\n</code></pre> <p>Process user-defined conferences and journals JSON files.</p> Notes <p>The structure of full_json_c follows the format     {\"publisher\": {\"conferences\": {\"abbr\": {\"names_abbr\": [], \"names_full\": []}}}}, while full_json_j adheres to the format     {\"publisher\": {\"journals\": {\"abbr\": {\"names_abbr\": [], \"names_full\": []}}}}.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def process_user_conferences_journals_json(full_json_c: str, full_json_j: str) -&gt; tuple[dict, dict]:\n    \"\"\"Process user-defined conferences and journals JSON files.\n\n    Notes:\n        The structure of full_json_c follows the format\n            {\"publisher\": {\"conferences\": {\"abbr\": {\"names_abbr\": [], \"names_full\": []}}}},\n        while full_json_j adheres to the format\n            {\"publisher\": {\"journals\": {\"abbr\": {\"names_abbr\": [], \"names_full\": []}}}}.\n    \"\"\"\n    # Process user conferences JSON file\n    json_dict = load_json_file(full_json_c)\n    full_abbr_inproceedings_dict = {}\n\n    # Try different possible keys for conferences section in JSON structure\n    for flag in [\"conferences\", \"Conferences\", \"CONFERENCES\", \"conference\", \"Conference\", \"CONFERENCE\"]:\n        full_abbr_inproceedings_dict = {p: json_dict[p].get(flag, {}) for p in json_dict}\n        if full_abbr_inproceedings_dict:\n            break\n\n    # Flatten the nested dictionary structure to {abbr: value} format\n    # Convert from {publisher: {abbr: data}} to {abbr: data}\n    full_abbr_inproceedings_dict = {abbr: v[abbr] for v in full_abbr_inproceedings_dict.values() for abbr in v}\n    # Standardize the structure to ensure consistent format\n    # Extract only usefull information (\"names_full\" and \"names_abbr\")\n    full_abbr_inproceedings_dict = {\n        k: {\"names_full\": v.get(\"names_full\", []), \"names_abbr\": v.get(\"names_abbr\", [])}\n        for k, v in full_abbr_inproceedings_dict.items()\n    }\n\n    # Process user journals JSON file\n    json_dict = load_json_file(full_json_j)\n    full_abbr_article_dict = {}\n\n    # Try different possible keys for journals section in JSON structure\n    for flag in [\"journals\", \"Journals\", \"JOURNALS\", \"journal\", \"Journal\", \"JOURNAL\"]:\n        full_abbr_article_dict = {p: json_dict[p].get(flag, {}) for p in json_dict}\n        if full_abbr_article_dict:\n            break\n\n    # Flatten the nested dictionary structure to {abbr: value} format\n    # Convert from {publisher: {abbr: data}} to {abbr: data}\n    full_abbr_article_dict = {abbr: v[abbr] for v in full_abbr_article_dict.values() for abbr in v}\n    # Standardize the structure to ensure consistent format\n    # Extract only usefull information (\"names_full\" and \"names_abbr\")\n    full_abbr_article_dict = {\n        k: {\"names_full\": v.get(\"names_full\", []), \"names_abbr\": v.get(\"names_abbr\", [])}\n        for k, v in full_abbr_article_dict.items()\n    }\n\n    # Return both processed dictionaries\n    return full_abbr_inproceedings_dict, full_abbr_article_dict\n</code></pre>"},{"location":"api-auto/main.utils/#pybibtexer.main.utils.read_str","title":"read_str","text":"<pre><code>read_str(full_file)\n</code></pre> <p>Read file content as string.</p> <p>Parameters:</p> Name Type Description Default <code>full_file</code> <code>str</code> <p>Path to the file to read.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Content of the file as string.</p> Source code in <code>pybibtexer/main/utils.py</code> <pre><code>def read_str(full_file: str) -&gt; str:\n    \"\"\"Read file content as string.\n\n    Args:\n        full_file: Path to the file to read.\n\n    Returns:\n        Content of the file as string.\n    \"\"\"\n    with open(full_file, encoding=\"utf-8\", newline=\"\\n\") as file:\n        content = file.read()\n    return content\n</code></pre>"},{"location":"api-auto/scripts.run_generate_jsons/","title":"scripts.run_generate_jsons","text":""},{"location":"api-auto/scripts.run_generate_jsons/#pybibtexer.scripts.run_generate_jsons-classes","title":"Classes","text":""},{"location":"api-auto/scripts.run_generate_jsons/#pybibtexer.scripts.run_generate_jsons-functions","title":"Functions","text":""},{"location":"api-auto/scripts.run_generate_jsons/#pybibtexer.scripts.run_generate_jsons.run_generate_jsons","title":"run_generate_jsons","text":"<pre><code>run_generate_jsons(\n    default_full_json_c,\n    default_full_json_j,\n    full_biblatex,\n    user_full_json_c,\n    user_full_json_j,\n    merge_json=False,\n)\n</code></pre> <p>Execute the JSON generation process for conferences and journals.</p> <p>Parameters:</p> Name Type Description Default <code>default_full_json_c</code> <code>str</code> <p>Path to the default conferences JSON file.</p> required <code>default_full_json_j</code> <code>str</code> <p>Path to the default journals JSON file.</p> required <code>full_biblatex</code> <code>str</code> <p>Path to the BibLaTeX source file.</p> required <code>user_full_json_c</code> <code>str</code> <p>Path to the user conferences JSON file.</p> required <code>user_full_json_j</code> <code>str</code> <p>Path to the user journals JSON file.</p> required <code>merge_json</code> <code>bool</code> <p>Whether to merge and save JSON data. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pybibtexer/scripts/run_generate_jsons.py</code> <pre><code>def run_generate_jsons(\n    default_full_json_c: str,\n    default_full_json_j: str,\n    full_biblatex: str,\n    user_full_json_c: str,\n    user_full_json_j: str,\n    merge_json: bool = False,\n) -&gt; None:\n    \"\"\"Execute the JSON generation process for conferences and journals.\n\n    Args:\n        default_full_json_c: Path to the default conferences JSON file.\n        default_full_json_j: Path to the default journals JSON file.\n        full_biblatex: Path to the BibLaTeX source file.\n        user_full_json_c: Path to the user conferences JSON file.\n        user_full_json_j: Path to the user journals JSON file.\n        merge_json: Whether to merge and save JSON data. Defaults to False.\n\n    Returns:\n        None\n    \"\"\"\n    default_full_json_c = os.path.expandvars(os.path.expanduser(default_full_json_c))\n    default_full_json_j = os.path.expandvars(os.path.expanduser(default_full_json_j))\n    full_biblatex = os.path.expandvars(os.path.expanduser(full_biblatex))\n    user_full_json_c = os.path.expandvars(os.path.expanduser(user_full_json_c))\n    user_full_json_j = os.path.expandvars(os.path.expanduser(user_full_json_j))\n\n    check = CheckAcronymAbbrAndFullDict()\n\n    # ==================== Conference Data Processing ====================\n    json_old_c = load_json_file(default_full_json_c)\n    json_new_c = parse_bibtex_file(full_biblatex, \"inproceedings\")\n\n    print(\"\\n\" + \"*\" * 9 + f\" Checking existing conference data: `{default_full_json_c}` \" + \"*\" * 9)\n    json_old_c, _ = check.length_dupicate_match(json_old_c)\n\n    print(\"\\n\" + \"*\" * 9 + f\" Checking newly parsed conference data: `{full_biblatex}` \" + \"*\" * 9)\n    json_new_c, _ = check.length_dupicate_match(json_new_c)\n\n    print(\"\\n\" + \"*\" * 9 + \" Comparing existing conference data with newly parsed conference data \" + \"*\" * 9)\n    json_new_c = check.compare_and_return_only_in_new(json_old_c, json_new_c)\n\n    # ==================== Journal Data Processing ====================\n    json_old_j = load_json_file(default_full_json_j)\n    json_new_j = parse_bibtex_file(full_biblatex, \"article\")\n\n    print(\"\\n\" + \"*\" * 9 + f\" Checking existing journal data: `{default_full_json_j}` \" + \"*\" * 9)\n    json_old_j, _ = check.length_dupicate_match(json_old_j)\n\n    print(\"\\n\" + \"*\" * 9 + f\" Checking newly parsed journal data: `{full_biblatex}` \" + \"*\" * 9)\n    json_new_j, _ = check.length_dupicate_match(json_new_j)\n\n    print(\"\\n\" + \"*\" * 9 + \" Comparing existing journal data with newly parsed journal data \" + \"*\" * 9)\n    json_new_j = check.compare_and_return_only_in_new(json_old_j, json_new_j)\n\n    # ==================== User Data Integration ====================\n    # Process user-specific conference and journal JSON files\n    json_user_c, json_user_j = process_user_conferences_journals_json(user_full_json_c, user_full_json_j)\n\n    # Check for duplicates in conferences data\n    print(\"\\n\" + \"*\" * 9 + \" Checking duplicates in conferences \" + \"*\" * 9)\n    c = {**json_new_c, **json_old_c, **json_user_c}  # Priority: user &gt; old &gt; new\n    c, c_matches = check.length_dupicate_match(c)\n    json_new_c = {k: v for k, v in json_new_c.items() if k not in c_matches}\n    c = {**json_new_c, **json_old_c, **json_user_c}  # Priority: user &gt; old &gt; new\n\n    # Check for duplicates in journals data\n    print(\"\\n\" + \"*\" * 9 + \" Checking duplicates in journals \" + \"*\" * 9)\n    j = {**json_new_j, **json_old_j, **json_user_j}  # Priority: user &gt; old &gt; new\n    j, f_matches = check.length_dupicate_match(j)\n    json_new_j = {k: v for k, v in json_new_j.items() if k not in f_matches}\n    j = {**json_new_j, **json_old_j, **json_user_j}  # Priority: user &gt; old &gt; new\n\n    # ==================== Data Merging and Saving ====================\n    if merge_json:\n        save_to_json(c, default_full_json_c)\n        save_to_json(j, default_full_json_j)\n        print(\"Data merging completed and saved\")\n\n    return None\n</code></pre>"},{"location":"api-auto/tools.compare.compare_bibs/","title":"tools.compare.compare_bibs","text":""},{"location":"api-auto/tools.compare.compare_bibs/#pybibtexer.tools.compare.compare_bibs-classes","title":"Classes","text":""},{"location":"api-auto/tools.compare.compare_bibs/#pybibtexer.tools.compare.compare_bibs-functions","title":"Functions","text":""},{"location":"api-auto/tools.compare.compare_bibs/#pybibtexer.tools.compare.compare_bibs.compare_bibs_with_local","title":"compare_bibs_with_local","text":"<pre><code>compare_bibs_with_local(\n    original_data,\n    path_spidered_bibs,\n    path_spidering_bibs,\n    path_output,\n    options,\n)\n</code></pre> <p>Compare bibliography entries with local bibliography collections.</p> <p>Processes original bibliography data and compares it against local bib files, categorizing entries into found, not found, and duplicate categories. Results are written to separate output files.</p> <p>Parameters:</p> Name Type Description Default <code>original_data</code> <code>list[str] | str</code> <p>Input bibliography data as string or list of strings</p> required <code>path_spidered_bibs</code> <code>str</code> <p>Path to pre-collected/spidered bibliography files</p> required <code>path_spidering_bibs</code> <code>str</code> <p>Path to actively spidered bibliography files</p> required <code>path_output</code> <code>str</code> <p>Output directory for result files</p> required <code>options</code> <code>dict[str, Any]</code> <p>Configuration options for comparison behavior</p> <p>compare_each_entry_with_all_local_bibs: Whether to compare each Entry with all local bib files.</p> required Source code in <code>pybibtexer/tools/compare/compare_bibs.py</code> <pre><code>def compare_bibs_with_local(\n    original_data: list[str] | str,\n    path_spidered_bibs: str,\n    path_spidering_bibs: str,\n    path_output: str,\n    options: dict[str, Any],\n) -&gt; None:\n    \"\"\"Compare bibliography entries with local bibliography collections.\n\n    Processes original bibliography data and compares it against local bib files,\n    categorizing entries into found, not found, and duplicate categories.\n    Results are written to separate output files.\n\n    Args:\n        original_data: Input bibliography data as string or list of strings\n        path_spidered_bibs: Path to pre-collected/spidered bibliography files\n        path_spidering_bibs: Path to actively spidered bibliography files\n        path_output: Output directory for result files\n        options: Configuration options for comparison behavior\n\n            compare_each_entry_with_all_local_bibs: Whether to compare each Entry with all local bib files.\n    \"\"\"\n    path_output = standard_path(path_output)\n\n    # generate for original data\n    _options = {}\n    _options.update(options)\n    _python_bib = PythonRunBib(_options)\n    data_list = transform_to_data_list(original_data, \".bib\")\n    library = _python_bib.parse_to_single_standard_library(data_list)\n    original_entry_keys = [entry.key for entry in library.entries]\n\n    # generate dict for abbr key entry\n    if options.get(\"compare_each_entry_with_all_local_bibs\"):\n        abbr_key_entries_dict: dict[str, dict[str, Block]] = {\"arXiv\": {entry.key: entry for entry in library.entries}}\n        not_in_local_entries = []\n    else:\n        abbr_key_entries_dict, not_in_local_entries = generate_abbr_key_entry_dict(library, options)\n\n    # compare with local bibs\n    tuple_entries = _compare_with_local(abbr_key_entries_dict, path_spidered_bibs, path_spidering_bibs, options)\n    searched_entries, not_searched_entries, duplicate_original_entries, duplicate_searched_entries = tuple_entries\n    not_in_local_entries.extend(not_searched_entries)\n\n    # write with sorting blocks according to original cite keys\n    _options = {}\n    _options[\"is_sort_entry_fields\"] = True  # default is True\n    _options[\"is_sort_blocks\"] = True  # default is True\n    _options[\"sort_entries_by_cite_keys\"] = original_entry_keys\n    _python_write = PythonWriters(_options)\n    _python_write.write_to_file(searched_entries, \"in_local_entries.bib\", \"w\", path_output, False)\n    _python_write.write_to_file(not_in_local_entries, \"not_in_local_entries.bib\", \"w\", path_output, False)\n\n    # write without sorting blocks\n    _options = {}\n    _options[\"is_sort_entry_fields\"] = True  # default is True\n    _options[\"is_sort_blocks\"] = False  # default is True\n    _python_write = PythonWriters(_options)\n    _python_write.write_to_file(duplicate_original_entries, \"duplicate_original_entries.bib\", \"w\", path_output, False)\n    _python_write.write_to_file(duplicate_searched_entries, \"duplicate_searched_entries.bib\", \"w\", path_output, False)\n    return None\n</code></pre>"},{"location":"api-auto/tools.compare.compare_bibs/#pybibtexer.tools.compare.compare_bibs.compare_bibs_with_zotero","title":"compare_bibs_with_zotero","text":"<pre><code>compare_bibs_with_zotero(\n    zotero_bib, download_bib, path_output, options\n)\n</code></pre> <p>Compare downloaded bibliography entries with Zotero library entries.</p> <p>Processes both Zotero export and downloaded bibliography files, then compares them to identify entries that exist only in the download set versus entries that exist in both collections.</p> <p>Parameters:</p> Name Type Description Default <code>zotero_bib</code> <code>list[str] | str</code> <p>Zotero exported bibliography data as string or list of strings</p> required <code>download_bib</code> <code>list[str] | str</code> <p>Downloaded bibliography data as string or list of strings</p> required <code>path_output</code> <code>str</code> <p>Output directory path for result files</p> required <code>options</code> <code>dict[str, Any]</code> <p>Configuration options for parsing and comparison behavior</p> required Source code in <code>pybibtexer/tools/compare/compare_bibs.py</code> <pre><code>def compare_bibs_with_zotero(\n    zotero_bib: list[str] | str, download_bib: list[str] | str, path_output: str, options: dict[str, Any]\n) -&gt; None:\n    \"\"\"Compare downloaded bibliography entries with Zotero library entries.\n\n    Processes both Zotero export and downloaded bibliography files, then compares\n    them to identify entries that exist only in the download set versus entries\n    that exist in both collections.\n\n    Args:\n        zotero_bib: Zotero exported bibliography data as string or list of strings\n        download_bib: Downloaded bibliography data as string or list of strings\n        path_output: Output directory path for result files\n        options: Configuration options for parsing and comparison behavior\n    \"\"\"\n    path_output = standard_path(path_output)\n\n    # for zotero bib\n    _options = {}\n    _options.update(options)\n    _options[\"generate_entry_cite_keys\"] = False  # default is False\n    _python_bib = PythonRunBib(_options)\n    data_list = transform_to_data_list(zotero_bib, \".bib\")\n    zotero_library = _python_bib.parse_to_single_standard_library(data_list)\n\n    # for download bib\n    _options = {}\n    _options.update(options)\n    _options[\"generate_entry_cite_keys\"] = True  # default is False\n    _python_bib = PythonRunBib(_options)\n    data_list = transform_to_data_list(download_bib, \".bib\")\n    download_library = _python_bib.parse_to_single_standard_library(data_list)\n\n    # compare download bib and zotero bib\n    only_in_download_entries, in_download_and_zotero_entries = [], []\n    for download_entry in download_library.entries:\n        flag = False\n        for zotero_entry in zotero_library.entries:\n            if check_equal_for_entry(zotero_entry, download_entry, [\"title\"], None):\n                in_download_and_zotero_entries.append(download_entry)\n                flag = True\n                break\n\n        if not flag:\n            only_in_download_entries.append(download_entry)\n\n    # write\n    _options = {}\n    _options.update(options)\n    _python_write = PythonWriters(_options)\n    _python_write.write_to_file(only_in_download_entries, \"only_in_download.bib\", \"w\", path_output, False)\n    _python_write.write_to_file(in_download_and_zotero_entries, \"in_download_and_zotero.bib\", \"w\", path_output, False)\n    return None\n</code></pre>"},{"location":"api-auto/tools.experiments_base/","title":"tools.experiments_base","text":""},{"location":"api-auto/tools.experiments_base/#pybibtexer.tools.experiments_base-classes","title":"Classes","text":""},{"location":"api-auto/tools.experiments_base/#pybibtexer.tools.experiments_base-functions","title":"Functions","text":""},{"location":"api-auto/tools.experiments_base/#pybibtexer.tools.experiments_base.generate_readme","title":"generate_readme","text":"<pre><code>generate_readme(\n    j_conf_abbr,\n    entry_type,\n    year_volume_number_month_entry_dict,\n)\n</code></pre> <p>Generates a README markdown file summarizing bibliography entries.</p> <p>Creates a formatted markdown table showing publication statistics organized by year, volume, number, and month.</p> <p>Parameters:</p> Name Type Description Default <code>j_conf_abbr</code> <code>str</code> <p>Journal/conference abbreviation for the title.</p> required <code>entry_type</code> <code>str</code> <p>Type of bibliography entries (article, inproceedings, etc.).</p> required <code>year_volume_number_month_entry_dict</code> <code>dict[str, dict[str, dict[str, dict[str, list[Entry]]]]]</code> <p>Nested dictionary structure containing entries organized by year, volume, number, and month.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Lines of the generated markdown file, or empty list if no valid entries.</p> Source code in <code>pybibtexer/tools/experiments_base.py</code> <pre><code>def generate_readme(\n    j_conf_abbr: str,\n    entry_type: str,\n    year_volume_number_month_entry_dict: dict[str, dict[str, dict[str, dict[str, list[Entry]]]]],\n) -&gt; list[str]:\n    \"\"\"Generates a README markdown file summarizing bibliography entries.\n\n    Creates a formatted markdown table showing publication statistics\n    organized by year, volume, number, and month.\n\n    Args:\n        j_conf_abbr: Journal/conference abbreviation for the title.\n        entry_type: Type of bibliography entries (article, inproceedings, etc.).\n        year_volume_number_month_entry_dict: Nested dictionary structure containing\n            entries organized by year, volume, number, and month.\n\n    Returns:\n        Lines of the generated markdown file, or empty list if no valid entries.\n    \"\"\"\n    # Configuration for different entry types.\n    entry_type_list = [\"article\", \"inproceedings\", \"misc\"]\n    filed_key_list = [\"journal\", \"booktitle\", \"publisher\"]\n\n    # Determine which field to display based on entry type.\n    field_key = \"\"\n    if (entry_type := entry_type.lower()) in entry_type_list:\n        field_key = filed_key_list[entry_type_list.index(entry_type)]\n\n    def extract_journal_booktitle(entries: list[Entry], field_key: str) -&gt; list[str]:\n        \"\"\"Extracts unique journal/booktitle values from entries.\n\n        Args:\n            entries: list of bibliography entries.\n            field_key: Field name to extract (journal, booktitle, etc.).\n\n        Returns:\n            List of unique field values in order of appearance.\n        \"\"\"\n        if field_key:\n            contents = []\n            for entry in entries:\n                value = entry[field_key] if field_key in entry else \"\"\n                contents.append(value)\n            return sorted(set(contents), key=contents.index)\n        return []\n\n    # Initialize markdown content with header.\n    readme = [f\"# {j_conf_abbr}-{entry_type.title()}\\n\\n\", f\"|Name|Year|Papers|{field_key.title()}|\\n\", \"|-|-|-|-|\\n\"]\n\n    # Process each hierarchical level to build the table.\n    for year in year_volume_number_month_entry_dict:\n        for volume in year_volume_number_month_entry_dict[year]:\n            for number in year_volume_number_month_entry_dict[year][volume]:\n                for month in year_volume_number_month_entry_dict[year][volume][number]:\n                    # Generate filename components.\n                    file_name = \"\"\n                    for i, j in zip([\"\", \"Vol.\", \"No.\", \"Month\"], [j_conf_abbr, volume, number, month], strict=True):\n                        if j.lower().strip() in [\"volume\", \"number\", \"month\"]:\n                            j = \"\"\n                        file_name += (i + j + \"-\") * (len(j.strip()) &gt;= 1)\n\n                    # Count papers and get journal/booktitle info.\n                    number_paper = len(temp := year_volume_number_month_entry_dict[year][volume][number][month])\n                    j_b = extract_journal_booktitle(temp, field_key)\n\n                    # Add table row.\n                    readme.append(f\"|{file_name[:-1]}|{year}|{number_paper}|{'; '.join(j_b)}|\" + \"\\n\")\n\n    # Only return content if we have more than just the header.\n    if len(readme) &gt; 3:\n        return readme\n    return []\n</code></pre>"},{"location":"api-auto/tools.experiments_base/#pybibtexer.tools.experiments_base.generate_standard_publisher_abbr_options_dict","title":"generate_standard_publisher_abbr_options_dict","text":"<pre><code>generate_standard_publisher_abbr_options_dict(\n    path_storage, options\n)\n</code></pre> <p>Generates a nested dictionary of publisher/abbreviation options.</p> <p>Creates a hierarchical dictionary structure representing all publishers and their abbreviations that match the inclusion/exclusion criteria.</p> <p>Parameters:</p> Name Type Description Default <code>path_storage</code> <code>str</code> <p>Root directory containing publisher/abbreviation folders.</p> required <code>options</code> <code>dict[str, Any]</code> <p>Configuration options including inclusion/exclusion lists.</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, dict[str, Any]]]</code> <p>Nested dictionary structure: - Top level: Publisher names. - Middle level: Abbreviation names. - Inner level: Copy of options dictionary.</p> Source code in <code>pybibtexer/tools/experiments_base.py</code> <pre><code>def generate_standard_publisher_abbr_options_dict(\n    path_storage: str, options: dict[str, Any]\n) -&gt; dict[str, dict[str, dict[str, Any]]]:\n    \"\"\"Generates a nested dictionary of publisher/abbreviation options.\n\n    Creates a hierarchical dictionary structure representing all publishers\n    and their abbreviations that match the inclusion/exclusion criteria.\n\n    Args:\n        path_storage: Root directory containing publisher/abbreviation folders.\n        options: Configuration options including inclusion/exclusion lists.\n\n    Returns:\n        Nested dictionary structure:\n            - Top level: Publisher names.\n            - Middle level: Abbreviation names.\n            - Inner level: Copy of options dictionary.\n    \"\"\"\n    if not os.path.exists(path_storage):\n        return {}\n\n    # First scan directory structure to find all publishers and abbreviations.\n    publisher_abbr_dict: dict[str, list[str]] = {}\n    publishers = [f for f in os.listdir(path_storage) if os.path.isdir(os.path.join(path_storage, f))]\n    for p in publishers:\n        path_p = os.path.join(path_storage, p)\n        publisher_abbr_dict.update({p: [f for f in os.listdir(path_p) if os.path.isdir(os.path.join(path_p, f))]})\n\n    # Apply inclusion/exclusion filters to publishers.\n    publisher_list = in_not_in_list(\n        list(publisher_abbr_dict.keys()),\n        options.get(\"include_publisher_list\", []),\n        options.get(\"exclude_publisher_list\", []),\n    )\n\n    # Build the nested options dictionary structure.\n    publisher_abbr_options_dict: dict[str, dict[str, dict[str, Any]]] = {}\n    for publisher in sort_int_str(publisher_list):\n        # Apply inclusion/exclusion filters to abbreviations.\n        abbr_list = in_not_in_list(\n            publisher_abbr_dict[publisher], options.get(\"include_abbr_list\", []), options.get(\"exclude_abbr_list\", [])\n        )\n\n        # Create nested structure with copied options.\n        for abbr_standard in sort_int_str(abbr_list):\n            publisher_abbr_options_dict.setdefault(publisher, {}).setdefault(abbr_standard, copy.deepcopy(options))\n    return publisher_abbr_options_dict\n</code></pre>"},{"location":"api-auto/tools.experiments_base/#pybibtexer.tools.experiments_base.in_not_in_list","title":"in_not_in_list","text":"<pre><code>in_not_in_list(original, in_list, out_list)\n</code></pre> <p>Filters a list based on inclusion and exclusion criteria.</p> <p>Parameters:</p> Name Type Description Default <code>original</code> <code>list[str]</code> <p>Original list to filter.</p> required <code>in_list</code> <code>list[str]</code> <p>list of items to include (case-insensitive).</p> required <code>out_list</code> <code>list[str]</code> <p>list of items to exclude (case-insensitive).</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Filtered list containing only items that: - Are in in_list (if in_list is not empty). - Are not in out_list.</p> Source code in <code>pybibtexer/tools/experiments_base.py</code> <pre><code>def in_not_in_list(original: list[str], in_list: list[str], out_list: list[str]) -&gt; list[str]:\n    \"\"\"Filters a list based on inclusion and exclusion criteria.\n\n    Args:\n        original: Original list to filter.\n        in_list: list of items to include (case-insensitive).\n        out_list: list of items to exclude (case-insensitive).\n\n    Returns:\n        Filtered list containing only items that:\n            - Are in in_list (if in_list is not empty).\n            - Are not in out_list.\n    \"\"\"\n    if in_list := [o.lower() for o in in_list]:\n        original = [o for o in original if o.lower() in in_list]\n    if out_list := [o.lower() for o in out_list]:\n        original = [o for o in original if o.lower() not in out_list]\n    return original\n</code></pre>"},{"location":"api-auto/tools.experiments_base/#pybibtexer.tools.experiments_base.obtain_local_abbr_paths","title":"obtain_local_abbr_paths","text":"<pre><code>obtain_local_abbr_paths(path_storage, options)\n</code></pre> <p>Gets all local abbreviation paths from the storage directory.</p> <p>Scans the specified storage directory and returns paths to all abbreviation subdirectories that match the inclusion/exclusion criteria in options.</p> <p>Parameters:</p> Name Type Description Default <code>path_storage</code> <code>str</code> <p>Root directory containing publisher/abbreviation folders.</p> required <code>options</code> <code>dict</code> <p>Configuration dictionary containing: - include_publisher_list: list of publishers to include. - exclude_publisher_list: list of publishers to exclude. - include_abbr_list: list of abbreviations to include. - exclude_abbr_list: list of abbreviations to exclude.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of full paths to all matching abbreviation directories.</p> Source code in <code>pybibtexer/tools/experiments_base.py</code> <pre><code>def obtain_local_abbr_paths(path_storage: str, options: dict) -&gt; list[str]:\n    \"\"\"Gets all local abbreviation paths from the storage directory.\n\n    Scans the specified storage directory and returns paths to all abbreviation\n    subdirectories that match the inclusion/exclusion criteria in options.\n\n    Args:\n        path_storage: Root directory containing publisher/abbreviation folders.\n        options: Configuration dictionary containing:\n            - include_publisher_list: list of publishers to include.\n            - exclude_publisher_list: list of publishers to exclude.\n            - include_abbr_list: list of abbreviations to include.\n            - exclude_abbr_list: list of abbreviations to exclude.\n\n    Returns:\n        List of full paths to all matching abbreviation directories.\n    \"\"\"\n    abbr_list = []\n    if not os.path.exists(path_storage):\n        return []\n\n    publisher_abbr_dict = generate_standard_publisher_abbr_options_dict(path_storage, options)\n    for publisher in publisher_abbr_dict:\n        for abbr in publisher_abbr_dict[publisher]:\n            abbr_list.append(os.path.join(path_storage, publisher, abbr))\n    return abbr_list\n</code></pre>"},{"location":"api-auto/tools.format_save_bibs/","title":"tools.format_save_bibs","text":""},{"location":"api-auto/tools.format_save_bibs/#pybibtexer.tools.format_save_bibs-classes","title":"Classes","text":""},{"location":"api-auto/tools.format_save_bibs/#pybibtexer.tools.format_save_bibs-functions","title":"Functions","text":""},{"location":"api-auto/tools.format_save_bibs/#pybibtexer.tools.format_save_bibs.format_bib_to_abbr_or_zotero_or_save_mode","title":"format_bib_to_abbr_or_zotero_or_save_mode","text":"<pre><code>format_bib_to_abbr_or_zotero_or_save_mode(\n    original_data, options\n)\n</code></pre> <p>Formats bibliography data to multiple standard formats and returns as data lists.</p> <p>Processes bibliography data and generates three standardized formats as string lists: abbreviated format, Zotero format, and save format.</p> <p>Parameters:</p> Name Type Description Default <code>original_data</code> <code>list[str] | str</code> <p>Input bibliography data as list of strings or file path.</p> required <code>options</code> <code>dict[str, Any]</code> <p>Processing configuration options.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Tuple containing three lists of strings representing the formatted bibliography data</p> <code>list[str]</code> <p>in abbreviated, Zotero, and save formats.</p> Source code in <code>pybibtexer/tools/format_save_bibs.py</code> <pre><code>def format_bib_to_abbr_or_zotero_or_save_mode(\n    original_data: list[str] | str, options: dict[str, Any]\n) -&gt; tuple[list[str], list[str], list[str]]:\n    \"\"\"Formats bibliography data to multiple standard formats and returns as data lists.\n\n    Processes bibliography data and generates three standardized formats as string lists:\n    abbreviated format, Zotero format, and save format.\n\n    Args:\n        original_data: Input bibliography data as list of strings or file path.\n        options: Processing configuration options.\n\n    Returns:\n        Tuple containing three lists of strings representing the formatted bibliography data\n        in abbreviated, Zotero, and save formats.\n    \"\"\"\n    # Generate for original data.\n    data_list = transform_to_data_list(original_data, \".bib\")\n\n    # Parse data to abbr_library, zotero_library, and save_library.\n    _options = {}\n    _options.update(options)\n    _python_bib = PythonRunBib(_options)\n    abbr_library, zotero_library, save_library = _python_bib.parse_to_multi_standard_library(data_list)\n\n    # Write with sorting blocks according to original cite keys.\n    _options = {}\n    _options.update(options)\n    _options[\"is_sort_entry_fields\"] = options.get(\"is_sort_entry_fields\", True)  # Default is True.\n    _options[\"is_sort_blocks\"] = options.get(\"is_sort_blocks\", False)  # Default is True.\n    _python_write = PythonWriters(_options)\n    return _python_write.write_multi_library_to_multi_data_list(abbr_library, zotero_library, save_library)\n</code></pre>"},{"location":"api-auto/tools.format_save_bibs/#pybibtexer.tools.format_save_bibs.format_bib_to_abbr_zotero_save_modes","title":"format_bib_to_abbr_zotero_save_modes","text":"<pre><code>format_bib_to_abbr_zotero_save_modes(\n    original_data, path_output, options\n)\n</code></pre> <p>Formats bibliography data to multiple standard formats.</p> <p>Processes bibliography data and generates three standardized formats: abbreviated format, Zotero format, and save format.</p> <p>Parameters:</p> Name Type Description Default <code>original_data</code> <code>list[str] | str</code> <p>Input bibliography data as list of strings or file path.</p> required <code>path_output</code> <code>str</code> <p>Output directory path for processed files.</p> required <code>options</code> <code>dict[str, Any]</code> <p>Processing configuration options.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pybibtexer/tools/format_save_bibs.py</code> <pre><code>def format_bib_to_abbr_zotero_save_modes(\n    original_data: list[str] | str, path_output: str, options: dict[str, Any]\n) -&gt; None:\n    \"\"\"Formats bibliography data to multiple standard formats.\n\n    Processes bibliography data and generates three standardized formats:\n    abbreviated format, Zotero format, and save format.\n\n    Args:\n        original_data: Input bibliography data as list of strings or file path.\n        path_output: Output directory path for processed files.\n        options: Processing configuration options.\n\n    Returns:\n        None\n    \"\"\"\n    path_output = standard_path(path_output)\n\n    # Generate for original data.\n    data_list = transform_to_data_list(original_data, \".bib\")\n\n    # Parse data to abbr_library, zotero_library, and save_library.\n    _options = {}\n    _options.update(options)\n    _python_bib = PythonRunBib(_options)\n    abbr_library, zotero_library, save_library = _python_bib.parse_to_multi_standard_library(data_list)\n\n    # Write with sorting blocks according to original cite keys.\n    _options = {}\n    _options.update(options)\n    _options[\"is_sort_entry_fields\"] = options.get(\"is_sort_entry_fields\", True)  # Default is True.\n    _options[\"is_sort_blocks\"] = options.get(\"is_sort_blocks\", False)  # Default is True.\n    _python_write = PythonWriters(_options)\n    _python_write.write_multi_library_to_multi_file(path_output, abbr_library, zotero_library, save_library)\n</code></pre>"},{"location":"api-auto/tools.format_save_bibs/#pybibtexer.tools.format_save_bibs.format_bib_to_save_mode_by_entry_type","title":"format_bib_to_save_mode_by_entry_type","text":"<pre><code>format_bib_to_save_mode_by_entry_type(\n    c_j_abbr,\n    path_output,\n    original_data,\n    combine_year_length=1,\n    default_year_list=None,\n    write_flag_bib=\"w\",\n    check_bib_exist=False,\n    write_flag_readme=\"w\",\n    check_md_exist=False,\n    options=None,\n)\n</code></pre> <p>Formats bibliography entries and organizes them by year and type.</p> <p>Processes bibliography data and organizes it into separate files by entry type and year, generating both BibTeX files and README documentation.</p> <p>Parameters:</p> Name Type Description Default <code>c_j_abbr</code> <code>str</code> <p>Conference/Journal abbreviation used for naming output files.</p> required <code>path_output</code> <code>str</code> <p>Output directory path for processed files.</p> required <code>original_data</code> <code>list[str] | str | Library</code> <p>Input bibliography data in various formats (list of strings, file path, file, raw string, or Library object).</p> required <code>combine_year_length</code> <code>int</code> <p>Number of years to combine in each output file.</p> <code>1</code> <code>default_year_list</code> <code>list[str] | None</code> <p>Specific years to process (if empty, processes all years).</p> <code>None</code> <code>write_flag_bib</code> <code>str</code> <p>Write mode for BibTeX files (\"w\" for write, \"a\" for append).</p> <code>'w'</code> <code>check_bib_exist</code> <code>bool</code> <p>Whether to check if BibTeX files exist before writing.</p> <code>False</code> <code>write_flag_readme</code> <code>str</code> <p>Write mode for README files (\"w\" for write, \"a\" for append).</p> <code>'w'</code> <code>check_md_exist</code> <code>bool</code> <p>Whether to check if README files exist before writing.</p> <code>False</code> <code>options</code> <code>dict[str, Any] | None</code> <p>Additional processing options.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pybibtexer/tools/format_save_bibs.py</code> <pre><code>def format_bib_to_save_mode_by_entry_type(\n    c_j_abbr: str,\n    path_output: str,\n    original_data: list[str] | str | Library,\n    combine_year_length: int = 1,\n    default_year_list: list[str] | None = None,\n    write_flag_bib: str = \"w\",\n    check_bib_exist: bool = False,\n    write_flag_readme: str = \"w\",\n    check_md_exist: bool = False,\n    options: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Formats bibliography entries and organizes them by year and type.\n\n    Processes bibliography data and organizes it into separate files by entry type and year,\n    generating both BibTeX files and README documentation.\n\n    Args:\n        c_j_abbr: Conference/Journal abbreviation used for naming output files.\n        path_output: Output directory path for processed files.\n        original_data: Input bibliography data in various formats (list of strings,\n            file path, file, raw string, or Library object).\n        combine_year_length: Number of years to combine in each output file.\n        default_year_list: Specific years to process (if empty, processes all years).\n        write_flag_bib: Write mode for BibTeX files (\"w\" for write, \"a\" for append).\n        check_bib_exist: Whether to check if BibTeX files exist before writing.\n        write_flag_readme: Write mode for README files (\"w\" for write, \"a\" for append).\n        check_md_exist: Whether to check if README files exist before writing.\n        options: Additional processing options.\n\n    Returns:\n        None\n    \"\"\"\n    if default_year_list is None:\n        default_year_list = []\n\n    if options is None:\n        options = {}\n\n    path_output = standard_path(path_output)\n\n    # Set up processing options.\n    _options = {}\n    _options.update(options)\n    _options[\"is_sort_entry_fields\"] = True  # Force field sorting.\n    _options[\"is_sort_blocks\"] = True  # Force block sorting.\n    _options[\"sort_entries_by_field_keys_reverse\"] = False  # Sort in ascending order, default is True.\n\n    # Initialize helper classes.\n    _python_bib = PythonRunBib(_options)\n\n    _options[\"empty_entry_cite_keys\"] = True  # Allow empty citation keys.\n    _python_writer = PythonWriters(_options)\n\n    # Organize entries by type, year, volume, number, and month.\n    entry_type_year_volume_number_month_entry_dict = _python_bib.parse_to_nested_entries_dict(original_data)\n\n    # Process each entry type separately.\n    for entry_type in entry_type_year_volume_number_month_entry_dict:\n        # Filter years if specified.\n        year_dict = entry_type_year_volume_number_month_entry_dict[entry_type]\n        year_list = sort_int_str(list(year_dict.keys()))\n        if default_year_list:\n            year_list = [y for y in year_list if y in default_year_list]\n        year_dict = {year: year_dict[year] for year in year_list}\n\n        # Save bibliography files grouped by years.\n        path_write = os.path.join(path_output, entry_type.lower(), \"bib\")\n        for i in range(math.ceil(len(year_list) / combine_year_length)):\n            # Determine year range for this file.\n            start_year_index = i * combine_year_length\n            end_year_index = min([(i + 1) * combine_year_length, len(year_list)])\n            combine_year = year_list[start_year_index:end_year_index]\n\n            # Create subset dictionary for these years.\n            new_year_dict = {year: year_dict[year] for year in combine_year}\n            entries: list[Block] = IterateCombineExtendDict().dict_update(copy.deepcopy(new_year_dict))\n\n            # Generate filename based on year range.\n            name = f\"{c_j_abbr}_{combine_year[0]}\"\n            if len(combine_year) &gt; 1:\n                name += f\"_{combine_year[-1]}\"\n            name += \".bib\"\n\n            # Write the bibliography file.\n            _python_writer.write_to_file(entries, name, write_flag_bib, path_write, check_bib_exist)\n\n        # Generate and save README documentation.\n        path_write = os.path.join(path_output, entry_type.lower())\n        readme_md = generate_readme(c_j_abbr, entry_type, year_dict)\n\n        # Handle append mode for README.\n        if re.search(\"a\", write_flag_readme):\n            old_readme_md = [re.sub(r\"[ ]+\", \"\", line) for line in read_list(\"README.md\", \"r\", path_write)]\n            readme_md = readme_md[3:] if old_readme_md else readme_md\n            readme_md = [line for line in readme_md if re.sub(r\"[ ]+\", \"\", line) not in old_readme_md]\n\n        write_list(readme_md, \"README.md\", write_flag_readme, path_write, check_md_exist)\n</code></pre>"},{"location":"api-auto/tools.format_save_bibs/#pybibtexer.tools.format_save_bibs.generate_statistic_information","title":"generate_statistic_information","text":"<pre><code>generate_statistic_information(path_storage)\n</code></pre> <p>Generates statistical information from bibliography files.</p> <p>Processes all BibTeX files in the directory tree and extracts key information (DOIs and URLs) into CSV files for analysis.</p> <p>Parameters:</p> Name Type Description Default <code>path_storage</code> <code>str</code> <p>Root directory containing BibTeX files to process.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pybibtexer/tools/format_save_bibs.py</code> <pre><code>def generate_statistic_information(path_storage: str) -&gt; None:\n    \"\"\"Generates statistical information from bibliography files.\n\n    Processes all BibTeX files in the directory tree and extracts key information\n    (DOIs and URLs) into CSV files for analysis.\n\n    Args:\n        path_storage: Root directory containing BibTeX files to process.\n\n    Returns:\n        None\n    \"\"\"\n    # Find all BibTeX files in the directory tree.\n    full_files = []\n    for root, _, files in os.walk(path_storage):\n        full_files.extend([os.path.join(root, f) for f in files if f.endswith(\".bib\")])\n\n    # Configure processing options.\n    _options = {\n        \"is_standardize_bib\": False,  # Skip standardization, default is True.\n        \"choose_abbr_zotero_save\": \"save\",  # Use save format, default is \"save\".\n        \"delete_field_list_for_save\": [],  # Do not delete any fields, default is [].\n        \"function_common_again\": False,  # Skip reprocessing, default is True.\n        \"function_common_again_abbr\": False,  # Skip abbreviation reprocessing, default is True.\n        \"function_common_again_zotero\": False,  # Skip Zotero reprocessing, default is True.\n        \"function_common_again_save\": False,  # Skip save format reprocessing, default is True.\n        \"is_sort_entry_fields\": False,  # Skip field sorting.\n        \"is_sort_blocks\": False,  # Skip block sorting.\n    }\n    _python_bib = PythonRunBib(_options)\n\n    # Process each BibTeX file.\n    for f in full_files:\n        informations = []\n        library = _python_bib.parse_to_single_standard_library(f)\n\n        # Extract DOI or URL for each entry.\n        for entry in library.entries:\n            flag = \"\"\n            if not flag:\n                flag = entry[\"doi\"] if \"doi\" in entry else \"\"\n            if not flag:\n                flag = entry[\"url\"] if \"url\" in entry else \"\"\n            informations.append(flag + \"\\n\")\n\n        # Write information to CSV file.\n        csv_path = f.replace(\".bib\", \".csv\").replace(f\"{os.sep}bib{os.sep}\", f\"{os.sep}url{os.sep}\")\n        write_list(informations, csv_path, \"w\", None, False)\n\n    return None\n</code></pre>"},{"location":"api-auto/tools.replace.replace/","title":"tools.replace.replace","text":""},{"location":"api-auto/tools.replace.replace/#pybibtexer.tools.replace.replace-classes","title":"Classes","text":""},{"location":"api-auto/tools.replace.replace/#pybibtexer.tools.replace.replace-functions","title":"Functions","text":""},{"location":"api-auto/tools.replace.replace/#pybibtexer.tools.replace.replace.replace_to_standard_cite_keys","title":"replace_to_standard_cite_keys","text":"<pre><code>replace_to_standard_cite_keys(\n    full_tex_md, full_bib, path_output, options\n)\n</code></pre> <p>Replace citation keys in TeX/Markdown files with standardized keys from BibTeX.</p> <p>Processes both LaTeX and Markdown files, replacing old citation keys with newly generated standardized keys while maintaining the corresponding BibTeX database.</p> <p>Parameters:</p> Name Type Description Default <code>full_tex_md</code> <code>str</code> <p>Path to TeX or Markdown file containing citations</p> required <code>full_bib</code> <code>str</code> <p>Path to BibTeX file with reference entries</p> required <code>path_output</code> <code>str</code> <p>Output directory for processed files</p> required <code>options</code> <code>dict[str, Any]</code> <p>Configuration options for key generation</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Lines of processed text content with updated citation keys</p> Source code in <code>pybibtexer/tools/replace/replace.py</code> <pre><code>def replace_to_standard_cite_keys(\n    full_tex_md: str, full_bib: str, path_output: str, options: dict[str, Any]\n) -&gt; list[str]:\n    \"\"\"Replace citation keys in TeX/Markdown files with standardized keys from BibTeX.\n\n    Processes both LaTeX and Markdown files, replacing old citation keys with newly\n    generated standardized keys while maintaining the corresponding BibTeX database.\n\n    Args:\n        full_tex_md: Path to TeX or Markdown file containing citations\n        full_bib: Path to BibTeX file with reference entries\n        path_output: Output directory for processed files\n        options: Configuration options for key generation\n\n    Returns:\n        list[str]: Lines of processed text content with updated citation keys\n    \"\"\"\n    # Validate input file type\n    ext = os.path.splitext(full_tex_md)[-1]\n    if ext not in [\".tex\", \".md\", \"md\", \"tex\"]:\n        print(f\"{full_tex_md} must be `.tex` or `.md` file.\")\n        return []\n\n    # Standardize output path and read BibTeX data\n    path_output = standard_path(path_output)\n    bib_data = transform_to_data_list(full_bib, \".bib\")\n\n    # Generate mapping from old to new citation keys\n    old_key_new_entry_dict = generate_old_key_new_entry_dict(bib_data, options)\n\n    # Read and process document content\n    data = \"\".join(transform_to_data_list(full_tex_md, ext))\n\n    # Replace citation keys in content\n    for old_key, new_entry in old_key_new_entry_dict.items():\n        if ext == \".tex\":\n            # LaTeX citation patterns: \\cite{}, \\citet{}, \\citep{}, and so on\n            data = re.sub(r\"\\\\cite([a-z]*){\\s*\" + old_key + r\"\\s*}\", r\"\\\\cite\\1{\" + new_entry.key + \"}\", data)\n            data = re.sub(r\"\\\\cite([a-z]*){\\s*\" + old_key + r\"\\s*,\", r\"\\\\cite\\1{\" + new_entry.key + \",\", data)\n            data = re.sub(r\",\\s*\" + old_key + r\"\\s*,\", r\",\" + new_entry.key + r\",\", data)\n            data = re.sub(r\",\\s*\" + old_key + r\"\\s*}\", r\",\" + new_entry.key + \"}\", data)\n        elif ext == \".md\":\n            # Markdown citation patterns: [@], comma-separated lists\n            data = re.sub(r\"\\[@\\s*\" + old_key + r\"\\s*\\]\", r\"[@\" + new_entry.key + \"]\", data)\n            data = re.sub(r\"\\[@\\s*\" + old_key + r\"\\s*,\", r\"[@\" + new_entry.key + \",\", data)\n            data = re.sub(r\",\\s*\" + old_key + r\"\\s*,\", r\",\" + new_entry.key + r\",\", data)\n            data = re.sub(r\",\\s*\" + old_key + r\"\\s*\\]\", r\",\" + new_entry.key + \"]\", data)\n        else:\n            pass\n\n    # Write processed document\n    data_list = data.splitlines(keepends=True)\n    write_list(data_list, f\"new{ext}\", \"w\", path_output, False)\n\n    # Write updated BibTeX file with new citation keys\n    _options = {}\n    _options.update(options)\n    _options[\"is_sort_blocks\"] = False  # Preserve original entry order and default is True\n    _python_write = PythonWriters(_options)\n    _python_write.write_to_file(list(old_key_new_entry_dict.values()), \"new.bib\", \"w\", path_output, False)\n    return data_list\n</code></pre>"},{"location":"api-auto/tools.spider.process_spider_bib/","title":"tools.spider.process_spider_bib","text":""},{"location":"api-auto/tools.spider.process_spider_bib/#pybibtexer.tools.spider.process_spider_bib-classes","title":"Classes","text":""},{"location":"api-auto/tools.spider.process_spider_bib/#pybibtexer.tools.spider.process_spider_bib.ProcessSpiderBib","title":"ProcessSpiderBib","text":"<pre><code>ProcessSpiderBib(path_abbr, abbr_standard)\n</code></pre> <p>Process spider bib.</p> <p>Parameters:</p> Name Type Description Default <code>path_abbr</code> <code>str</code> <p>The path of the abbreviation folder.</p> required <code>abbr_standard</code> <code>str</code> <p>The standard abbreviation.</p> required <p>Attributes:</p> Name Type Description <code>path_abbr</code> <p>The path of the abbreviation folder.</p> <code>abbr_standard</code> <p>The standard abbreviation.</p> Source code in <code>pybibtexer/tools/spider/process_spider_bib.py</code> <pre><code>def __init__(self, path_abbr: str, abbr_standard: str) -&gt; None:\n    self.path_abbr = os.path.expandvars(os.path.expanduser(path_abbr))\n    self.abbr_standard = abbr_standard\n\n    self._options = {\n        \"is_standardize_bib\": True,  # default is True\n        \"substitute_old_list\": [\n            r\"(&lt;[a-zA-Z\\-]+\\s*/*\\s*&gt;)\",\n            r\"(&lt;/[a-zA-Z\\-]+&gt;)\",\n            r'(&lt;[a-zA-Z\\-]+ [^\\s]+=\"[^&gt;]+?\"\\s*/*\\s*&gt;)',\n            r\"([ ]+)\",\n            r\";[; ]*;\",\n            r\",[, ]*,\",\n        ],\n        \"substitute_new_list\": [\"\", \"\", \"\", \" \", \";\", \",\"],\n        \"choose_abbr_zotero_save\": \"save\",  # default is \"save\"\n        \"delete_field_list_for_save\": [],  # default is []\n        \"is_sort_entry_fields\": True,  # default is False\n        \"is_sort_blocks\": True,  # default is False\n        \"sort_entries_by_field_keys_reverse\": False,  # default is True\n        \"empty_entry_cite_keys\": True,\n    }\n\n    self._python_bib = PythonRunBib(self._options)\n</code></pre>"},{"location":"api-auto/tools.spider.process_spider_bib/#pybibtexer.tools.spider.process_spider_bib.ProcessSpiderBib-functions","title":"Functions","text":""},{"location":"api-auto/tools.spider.process_spider_bib/#pybibtexer.tools.spider.process_spider_bib.ProcessSpiderBib.check_spider_bib","title":"check_spider_bib","text":"<pre><code>check_spider_bib(delete_duplicate_in_bibs=False)\n</code></pre> <p>Check bib.</p> Source code in <code>pybibtexer/tools/spider/process_spider_bib.py</code> <pre><code>def check_spider_bib(self, delete_duplicate_in_bibs: bool = False) -&gt; None:\n    \"\"\"Check bib.\"\"\"\n    bibs_name = iterate_obtain_full_file_names(self.path_abbr, \".bib\", False)\n    bibs_name = [[f, os.path.basename(f).split(\".\")[0].strip()] for f in bibs_name]\n\n    urls_name = iterate_obtain_full_file_names(self.path_abbr, \".csv\", False)\n    urls_name = [[f, os.path.basename(f).split(\".\")[0].strip()] for f in urls_name]\n\n    url_base_names = [name[-1] for name in urls_name]\n\n    _options = {}\n    _options.update(self._options)\n    _python_writer = PythonWriters(_options)\n\n    for name in bibs_name:\n        bib_base_name = name[-1]\n        if bib_base_name not in url_base_names:\n            print(f\"{bib_base_name}.csv not in the folder `url`.\")\n            continue\n\n        full_bib, full_url = name[0], urls_name[url_base_names.index(bib_base_name)][0]\n\n        print(\"*\" * 5 + f\" Check {os.path.basename(full_bib)} and {os.path.basename(full_url)} \" + \"*\" * 5)\n        bib_list = read_list(full_bib, \"r\")\n\n        # Check duplicated blocks in bib file\n        library = self._python_bib.parse_to_single_standard_library(bib_list)\n\n        url_bib_dict = {}\n        for entry in library.entries:\n            doi = entry[\"doi\"] if \"doi\" in entry else \"\"\n            url_ = entry[\"url\"] if \"url\" in entry else \"\"\n            url = doi if doi else url_\n            url_bib_dict.setdefault(url, []).append(entry)\n\n        duplicate_url, new_entries = [], []\n        for url in url_bib_dict:\n            if len(url_bib_dict[url]) &gt; 1:\n                duplicate_url.append(url)\n            if delete_duplicate_in_bibs:\n                new_entries.append(url_bib_dict[url][0])\n\n        # Delete duplicated blocks in bib file\n        if duplicate_url:\n            print(f\"Duplicates in {full_bib}: {duplicate_url}\\n\")\n        if duplicate_url and delete_duplicate_in_bibs:\n            _python_writer.write_to_file(new_entries, full_bib, \"w\", None, False)\n    return None\n</code></pre>"},{"location":"api-auto/tools.spider.process_spider_bib/#pybibtexer.tools.spider.process_spider_bib.ProcessSpiderBib.format_spider_bib","title":"format_spider_bib","text":"<pre><code>format_spider_bib(write_bib=False)\n</code></pre> <p>Format spider bib.</p> Source code in <code>pybibtexer/tools/spider/process_spider_bib.py</code> <pre><code>def format_spider_bib(self, write_bib: bool = False) -&gt; None:\n    \"\"\"Format spider bib.\"\"\"\n    file_list = iterate_obtain_full_file_names(self.path_abbr, \".bib\", False)\n\n    if write_bib:\n        if os.path.exists(readme := os.path.join(self.path_abbr, \"README.md\")):\n            os.remove(readme)\n\n    _options = {}\n    _options.update(self._options)\n    _python_writer = PythonWriters(_options)\n\n    for f in file_list:\n        print(\"*\" * 5 + f\" Format {os.path.basename(f)} \" + \"*\" * 5)\n\n        data_list = read_list(f, \"r\")\n\n        # standardize\n        entry_type_year_volume_number_month_entry_dict = self._python_bib.parse_to_nested_entries_dict(data_list)\n        if not write_bib:\n            continue\n\n        # just for the necessary part\n        old_readme_md = [re.sub(r\"[ ]+\", \"\", line) for line in read_list(\"README.md\", \"r\", self.path_abbr)]\n        new_readme_md = []\n        new_entry_list = []\n\n        for entry_type in entry_type_year_volume_number_month_entry_dict:\n            new_dict = entry_type_year_volume_number_month_entry_dict.get(entry_type.lower(), {})\n\n            # for README.md\n            readme_md = generate_readme(self.abbr_standard, entry_type.lower(), new_dict)\n            readme_md = readme_md[3:] if (old_readme_md or new_readme_md) else readme_md\n            readme_md = [line for line in readme_md if re.sub(r\"[ ]+\", \"\", line) not in old_readme_md]\n            new_readme_md.extend(readme_md)\n\n            # for bib\n            entry_list = IterateCombineExtendDict().dict_update(copy.deepcopy(new_dict))\n            new_entry_list.extend(entry_list)\n\n        write_list(new_readme_md, \"README.md\", \"a\", self.path_abbr, False)\n        _python_writer.write_to_file(new_entry_list, f, \"w\", None, False)\n    return None\n</code></pre>"},{"location":"api-auto/tools.spider.process_spider_bib/#pybibtexer.tools.spider.process_spider_bib-functions","title":"Functions","text":""},{"location":"api-auto/tools.spider.process_spider_url/","title":"tools.spider.process_spider_url","text":""},{"location":"api-auto/tools.spider.process_spider_url/#pybibtexer.tools.spider.process_spider_url-classes","title":"Classes","text":""},{"location":"api-auto/tools.spider.process_spider_url/#pybibtexer.tools.spider.process_spider_url.ProcessSpiderUrl","title":"ProcessSpiderUrl","text":"<pre><code>ProcessSpiderUrl(path_abbr, abbr_standard)\n</code></pre> <p>Process spider URL.</p> <p>Parameters:</p> Name Type Description Default <code>path_abbr</code> <code>str</code> <p>path to abbreviation</p> required <code>abbr_standard</code> <code>str</code> <p>abbreviation standard</p> required <p>Attributes:</p> Name Type Description <code>path_abbr</code> <code>str</code> <p>path to abbreviation</p> <code>abbr_standard</code> <code>str</code> <p>abbreviation standard</p> Source code in <code>pybibtexer/tools/spider/process_spider_url.py</code> <pre><code>def __init__(self, path_abbr, abbr_standard: str) -&gt; None:\n    self.path_abbr = os.path.expandvars(os.path.expanduser(path_abbr))\n    self.abbr_standard = abbr_standard\n</code></pre>"},{"location":"api-auto/tools.spider.process_spider_url_bib/","title":"tools.spider.process_spider_url_bib","text":""},{"location":"api-auto/tools.spider.process_spider_url_bib/#pybibtexer.tools.spider.process_spider_url_bib-classes","title":"Classes","text":""},{"location":"api-auto/tools.spider.process_spider_url_bib/#pybibtexer.tools.spider.process_spider_url_bib.CheckDeleteFormatMoveSpideredBibs","title":"CheckDeleteFormatMoveSpideredBibs","text":"<pre><code>CheckDeleteFormatMoveSpideredBibs(\n    path_storage, path_shutil, options\n)\n</code></pre> <p>Experiment for check.</p> <p>Parameters:</p> Name Type Description Default <code>path_storage</code> <code>str</code> <p>path to storage</p> required <code>path_shutil</code> <code>str</code> <p>path to shutil</p> required <code>options</code> <code>dict[str, Any]</code> <p>options for check, delete, format</p> required <p>Attributes:</p> Name Type Description <code>path_storage</code> <code>str</code> <p>path to storage</p> <code>path_shutil</code> <code>str</code> <p>path to shutil</p> <code>publisher_abbr_dict</code> <code>dict[str, dict[str, Any]]</code> <p>publisher abbreviation options dict</p> Source code in <code>pybibtexer/tools/spider/process_spider_url_bib.py</code> <pre><code>def __init__(self, path_storage: str, path_shutil: str, options: dict[str, Any]) -&gt; None:\n    self.path_storage = standard_path(path_storage)\n    self.path_shutil = standard_path(path_shutil)\n    self.publisher_abbr_dict = generate_standard_publisher_abbr_options_dict(self.path_storage, options)\n</code></pre>"},{"location":"api-auto/tools.spider.process_spider_url_bib/#pybibtexer.tools.spider.process_spider_url_bib-functions","title":"Functions","text":""},{"location":"api-auto/utils.utils/","title":"utils.utils","text":""},{"location":"api-manual/","title":"API Reference","text":""},{"location":"users-guide/bug-report/","title":"Bug Report","text":""},{"location":"users-guide/installation/","title":"Installation","text":"<ul> <li>uv</li> </ul> <pre><code>uv add pybibtexer\n</code></pre> <ul> <li>pip</li> </ul> <pre><code>pip install pybibtexer\n</code></pre>"},{"location":"users-guide/pull-request/","title":"Pull Request","text":""}]}